var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { isReactive, reactive, ref, watch, provide, inject, toRef, watchEffect, computed, unref, onMounted, onUnmounted, defineComponent, openBlock, createElementBlock, useAttrs, Fragment, mergeProps, createCommentVNode, createElementVNode, createTextVNode, toDisplayString, renderList, normalizeClass, withModifiers, renderSlot, createVNode, createBlock, normalizeStyle, TransitionGroup, withCtx, resolveDynamicComponent, readonly, nextTick, resolveComponent, normalizeProps, guardReactiveProps, createSlots } from "vue";
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf(data, key);
  return index < 0 ? void 0 : data[index][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal$1 = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal$1 || freeSelf || Function("return this")();
var root$1 = root;
var Symbol$1 = root$1.Symbol;
var Symbol$2 = Symbol$1;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root$1["__core-js_shared__"];
var coreJsData$1 = coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var Map$1 = getNative(root$1, "Map");
var Map$2 = Map$1;
var nativeCreate = getNative(Object, "create");
var nativeCreate$1 = nativeCreate;
function hashClear() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$9.call(data, key) ? data[key] : void 0;
}
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$8.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate$1 && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$2 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache, key) {
  return cache.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack.set(array, other);
  stack.set(other, array);
  while (++index < arrLength) {
    var arrValue = array[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array);
  stack["delete"](other);
  return result;
}
var Uint8Array2 = root$1.Uint8Array;
var Uint8Array$1 = Uint8Array2;
function mapToArray(map) {
  var index = -1, result = Array(map.size);
  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : void 0, symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      return eq(+object, +other);
    case errorTag$1:
      return object.name == other.name && object.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object == other + "";
    case mapTag$2:
      var convert = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var isArray = Array.isArray;
var isArray$1 = isArray;
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
}
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$9 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};
var getSymbols$1 = getSymbols;
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable = objectProto$8.propertyIsEnumerable;
var isArguments = baseIsArguments(function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$7.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments$1 = isArguments;
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root$1.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var isBuffer$1 = isBuffer;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$3 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal$1.process;
var nodeUtil = function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil$1 = nodeUtil;
var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray$1 = isTypedArray;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray$1(value), isArg = !isArr && isArguments$1(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$6.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$6 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$6;
  return value === proto;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var nativeKeys$1 = nativeKeys;
var objectProto$5 = Object.prototype;
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys$1(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$5.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols$1);
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$4.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object);
  stack["delete"](other);
  return result;
}
var DataView = getNative(root$1, "DataView");
var DataView$1 = DataView;
var Promise$1 = getNative(root$1, "Promise");
var Promise$2 = Promise$1;
var Set$1 = getNative(root$1, "Set");
var Set$2 = Set$1;
var WeakMap = getNative(root$1, "WeakMap");
var WeakMap$1 = WeakMap;
var mapTag = "[object Map]", objectTag$2 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$2), promiseCtorString = toSource(Promise$2), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$2 && getTag(new Map$2()) != mapTag || Promise$2 && getTag(Promise$2.resolve()) != promiseTag || Set$2 && getTag(new Set$2()) != setTag || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$2 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var getTag$1 = getTag;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag$1 = "[object Object]";
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$1(object), othIsArr = isArray$1(other), objTag = objIsArr ? arrayTag : getTag$1(object), othTag = othIsArr ? arrayTag : getTag$1(other);
  objTag = objTag == argsTag ? objectTag$1 : objTag;
  othTag = othTag == argsTag ? objectTag$1 : othTag;
  var objIsObj = objTag == objectTag$1, othIsObj = othTag == objectTag$1, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer$1(object)) {
    if (!isBuffer$1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray$1(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$3.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$3.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
function Reactive(value) {
  if (isReactive(value)) {
    return value;
  } else {
    return reactive(value);
  }
}
function nonNull(val, name = "Parameter") {
  if (val === void 0 || val === null) {
    throw new Error(`${name} is null`);
  }
  return val;
}
function bindProp(props, name, emit, filter) {
  if (filter) {
    const prop2 = ref(filter(props[name]));
    const update = (filtered) => {
      if (!isEqual(filtered, prop2.value)) {
        prop2.value = filtered;
      }
      if (!isEqual(filtered, props[name])) {
        emit(`update:${name}`, filtered);
      }
    };
    watch(() => filter(prop2.value), update);
    watch(() => props[name], (v) => update(filter(v)));
    if (prop2.value !== props[name]) {
      emit(`update:${name}`, prop2.value);
    }
    return prop2;
  }
  const prop = ref(props[name]);
  watch(() => props[name], (v) => {
    if (!isEqual(v, prop.value)) {
      prop.value = v;
    }
  });
  watch(prop, (v) => {
    if (!isEqual(v, props[name])) {
      emit(`update:${name}`, v);
    }
  });
  return prop;
}
function bindPropKeySet(props, name, sourceObject, emit) {
  const bound = reactive(new Set());
  watch(() => props[name], () => {
    const prop = props[name];
    const filtered = prop.filter((n) => n in sourceObject);
    if (!isEqual(filtered, bound)) {
      bound.clear();
      filtered.forEach(bound.add, bound);
    }
  }, { immediate: true });
  watch(bound, () => {
    const array = Array.from(bound);
    if (!isEqual(props[name], array)) {
      emit(`update:${name}`, array);
    }
  });
  return Reactive(bound);
}
const containersKey = Symbol("containers");
function provideContainers(containers) {
  provide(containersKey, containers);
}
function useContainers() {
  const containers = nonNull(inject(containersKey), "containers");
  return {
    container: containers.container,
    svg: containers.svg,
    svgPanZoom: containers.svgPanZoom
  };
}
class Config {
  static value(value, target) {
    return value instanceof Function ? value(target) : value;
  }
  static values(value, target) {
    if (Object.values(value).filter((v) => v instanceof Function).length === 0) {
      return value;
    }
    return Object.fromEntries(Object.entries(value).map(([k, v]) => [k, v instanceof Function ? v(target) : v]));
  }
}
var NodeLabelDirection;
(function(NodeLabelDirection2) {
  NodeLabelDirection2[NodeLabelDirection2["CENTER"] = 0] = "CENTER";
  NodeLabelDirection2[NodeLabelDirection2["NORTH"] = 1] = "NORTH";
  NodeLabelDirection2[NodeLabelDirection2["NORTH_EAST"] = 2] = "NORTH_EAST";
  NodeLabelDirection2[NodeLabelDirection2["EAST"] = 3] = "EAST";
  NodeLabelDirection2[NodeLabelDirection2["SOUTH_EAST"] = 4] = "SOUTH_EAST";
  NodeLabelDirection2[NodeLabelDirection2["SOUTH"] = 5] = "SOUTH";
  NodeLabelDirection2[NodeLabelDirection2["SOUTH_WEST"] = 6] = "SOUTH_WEST";
  NodeLabelDirection2[NodeLabelDirection2["WEST"] = 7] = "WEST";
  NodeLabelDirection2[NodeLabelDirection2["NORTH_WEST"] = 8] = "NORTH_WEST";
})(NodeLabelDirection || (NodeLabelDirection = {}));
function withSelf(callback) {
  const self2 = {};
  return Object.assign(self2, callback(self2));
}
function configsWithType(configs) {
  return configs;
}
function entriesOf(obj) {
  return Object.entries(obj);
}
function updateObjectDiff(target, from) {
  const keys2 = new Set(Object.keys(target));
  entriesOf(from).forEach(([key, value]) => {
    if (!isEqual(target[key], value)) {
      target[key] = value;
    }
    keys2.delete(key);
  });
  keys2.forEach((k) => delete target[k]);
}
function getNodeSize(node, style, scale) {
  const shape = Config.values(style.normal, node);
  if (shape.type == "circle") {
    return {
      width: shape.radius * 2 * scale,
      height: shape.radius * 2 * scale
    };
  } else {
    return {
      width: shape.width * scale,
      height: shape.height * scale
    };
  }
}
function areNodesCollision(nodePos, nodeSize, targetNodePos, targetNodeSize) {
  const distanceX = Math.abs(nodePos.x - targetNodePos.x);
  const collisionX = distanceX < nodeSize.width / 2 + targetNodeSize.width / 2;
  const distanceY = Math.abs(nodePos.y - targetNodePos.y);
  const collisionY = distanceY < nodeSize.height / 2 + targetNodeSize.height / 2;
  return collisionX && collisionY;
}
function applyScaleToDasharray(dasharray, scale) {
  let result = 0;
  if (scale === 1 || dasharray === void 0 || dasharray === "none") {
    result = dasharray != null ? dasharray : 0;
  } else if (typeof dasharray === "string") {
    result = dasharray.split(/\s+/).map((v) => parseInt(v) * scale).filter((v) => !isNaN(v)).join(" ");
  } else {
    result = dasharray * scale;
  }
  return result && result !== "0" ? result : void 0;
}
function getDasharrayUnit(dasharray) {
  let result = 0;
  if (dasharray === void 0 || dasharray === "none") {
    result = 0;
  } else if (typeof dasharray === "string") {
    const array = dasharray.split(/\s+/).map((v) => parseInt(v)).filter((v) => !isNaN(v));
    if (array.length % 2 === 0) {
      result = array.reduce((s, n) => s + n, 0);
    } else {
      result = array.reduce((s, n) => s + n, 0) * 2;
    }
  } else {
    result = dasharray * 2;
  }
  return result;
}
class MapUtil {
  static valueOf(map) {
    return Array.from(map.values());
  }
}
function findFirstNonNull(...values) {
  return values.find((v) => !!v);
}
var reWhitespace = /\s/;
function trimmedEndIndex(string) {
  var index = string.length;
  while (index-- && reWhitespace.test(string.charAt(index))) {
  }
  return index;
}
var reTrimStart = /^\s+/;
function baseTrim(string) {
  return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
}
var symbolTag = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
}
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var INFINITY$2 = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY$2 || value === -INFINITY$2) {
    var sign = value < 0 ? -1 : 1;
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
function toInteger(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
function arrayMap(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}
var INFINITY$1 = 1 / 0;
var symbolProto = Symbol$2 ? Symbol$2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$1(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$1 ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
var nativeIsFinite = root$1.isFinite, nativeMin = Math.min;
function createRound(methodName) {
  var func = Math[methodName];
  return function(number, precision) {
    number = toNumber(number);
    precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
    if (precision && nativeIsFinite(number)) {
      var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
      pair = (toString(value) + "e").split("e");
      return +(pair[0] + "e" + (+pair[1] - precision));
    }
    return func(number);
  };
}
var round = createRound("round");
var round$1 = round;
const NEW_NODE_POSITION_MARGIN = 20;
class SimpleLayout {
  activate(parameters) {
    const { layouts, nodes, configs, emitter, scale, svgPanZoom: svgPanZoom2 } = parameters;
    const onDrag = (positions) => {
      for (const [id, pos] of Object.entries(positions)) {
        const layout = this.getOrCreateNodePosition(layouts, id);
        this.setNodePosition(layout, pos);
      }
    };
    const setNewNodePositions = (nodeIds) => {
      const newNodes = nodeIds.filter((n) => !(n in layouts));
      const area = svgPanZoom2.getViewArea();
      const s = scale.value;
      for (const nodeId of newNodes) {
        const node = nodes[nodeId];
        const nodeSize = getNodeSize(node, configs.node, s);
        const candidate = __spreadValues({}, area.center);
        for (; ; ) {
          let collision = false;
          for (const [id, pos] of Object.entries(layouts)) {
            if (nodeId === id)
              continue;
            const targetNode = nodes[id];
            if (!targetNode)
              continue;
            const targetNodeSize = getNodeSize(targetNode, configs.node, s);
            collision = areNodesCollision(candidate, nodeSize, pos, targetNodeSize);
            if (collision) {
              break;
            }
          }
          if (collision) {
            candidate.x += nodeSize.width + NEW_NODE_POSITION_MARGIN * s;
            if (candidate.x + nodeSize.width / 2 > area.box.right) {
              candidate.x = area.center.x;
              candidate.y += nodeSize.height + NEW_NODE_POSITION_MARGIN * s;
            }
          } else {
            break;
          }
        }
        const layout = this.getOrCreateNodePosition(layouts, nodeId);
        this.setNodePosition(layout, candidate);
      }
    };
    setNewNodePositions(Object.keys(nodes));
    const stopNodeWatch = watch(() => Object.keys(nodes), setNewNodePositions);
    emitter.on("node:dragstart", onDrag);
    emitter.on("node:pointermove", onDrag);
    emitter.on("node:dragend", onDrag);
    this.onDeactivate = () => {
      stopNodeWatch();
      emitter.off("node:dragstart", onDrag);
      emitter.off("node:pointermove", onDrag);
      emitter.off("node:dragend", onDrag);
    };
  }
  deactivate() {
    if (this.onDeactivate) {
      this.onDeactivate();
    }
  }
  setNodePosition(nodeLayout, pos) {
    nodeLayout.value.x = round$1(pos.x, 3);
    nodeLayout.value.y = round$1(pos.y, 3);
  }
  getOrCreateNodePosition(layouts, node) {
    const layout = toRef(layouts, node);
    if (!layout.value) {
      layout.value = { x: 0, y: 0 };
    }
    return layout;
  }
}
var defineProperty = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty$1 = defineProperty;
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty$1) {
    defineProperty$1(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
var baseFor$1 = baseFor;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer2 = moduleExports ? root$1.Buffer : void 0, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate$1 = baseCreate;
var getPrototype = overArg(Object.getPrototypeOf, Object);
var getPrototype$1 = getPrototype;
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate$1(getPrototype$1(object)) : {};
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
var objectTag = "[object Object]";
var funcProto = Function.prototype, objectProto$2 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype$1(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$1.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray$1(srcValue), isBuff = !isArr && isBuffer$1(srcValue), isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray$1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
      newValue = objValue;
      if (isArguments$1(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor$1(source, function(srcValue, key) {
    stack || (stack = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function identity(value) {
  return value;
}
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var nativeMax$1 = Math.max;
function overRest(func, start, transform) {
  start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var baseSetToString$1 = baseSetToString;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var setToString = shortOut(baseSetToString$1);
var setToString$1 = setToString;
function baseRest(func, start) {
  return setToString$1(overRest(func, start, identity), func + "");
}
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
    return eq(object[index], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
var merge$1 = merge;
function getConfigDefaults() {
  return {
    view: {
      scalingObjects: false,
      panEnabled: true,
      zoomEnabled: true,
      minZoomLevel: 0.1,
      maxZoomLevel: 64,
      fit: false,
      layoutHandler: new SimpleLayout(),
      onSvgPanZoomInitialized: void 0,
      grid: {
        visible: false,
        interval: 10,
        thickIncrements: 5,
        line: {
          color: "#e0e0e0",
          width: 1,
          dasharray: 1
        },
        thick: {
          color: "#cccccc",
          width: 1,
          dasharray: 0
        }
      }
    },
    node: withSelf((self2) => ({
      normal: {
        type: "circle",
        radius: 16,
        width: 32,
        height: 32,
        borderRadius: 4,
        color: "#4466cc",
        strokeWidth: 0,
        strokeColor: "#000000",
        strokeDasharray: 0
      },
      hover: {
        type: (node) => Config.value(self2.normal.type, node),
        radius: (node) => {
          var _a;
          return ((_a = Config.value(self2.normal.radius, node)) != null ? _a : 0) + 2;
        },
        width: (node) => {
          var _a;
          return ((_a = Config.value(self2.normal.width, node)) != null ? _a : 0) + 2;
        },
        height: (node) => {
          var _a;
          return ((_a = Config.value(self2.normal.height, node)) != null ? _a : 0) + 2;
        },
        borderRadius: (node) => {
          var _a;
          return (_a = Config.value(self2.normal.borderRadius, node)) != null ? _a : 0;
        },
        strokeWidth: (node) => Config.value(self2.normal.strokeWidth, node),
        strokeColor: (node) => Config.value(self2.normal.strokeColor, node),
        strokeDasharray: (node) => Config.value(self2.normal.strokeDasharray, node),
        color: "#3355bb"
      },
      selected: void 0,
      draggable: true,
      selectable: false,
      label: {
        visible: true,
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        margin: 4,
        direction: NodeLabelDirection.SOUTH,
        text: "name"
      },
      focusring: {
        visible: true,
        width: 4,
        padding: 3,
        color: "#eebb00"
      },
      transition: void 0
    })),
    edge: withSelf((self2) => ({
      normal: {
        width: 2,
        color: "#4466cc",
        dasharray: 0,
        linecap: "butt",
        animate: false,
        animationSpeed: 50
      },
      hover: {
        width: (edge) => Config.value(self2.normal.width, edge) + 1,
        color: "#3355bb",
        dasharray: (edge) => Config.value(self2.normal.dasharray, edge),
        linecap: (edge) => Config.value(self2.normal.linecap, edge),
        animate: (edge) => Config.value(self2.normal.animate, edge),
        animationSpeed: (edge) => Config.value(self2.normal.animationSpeed, edge)
      },
      selected: {
        width: (edge) => Config.value(self2.normal.width, edge) + 1,
        color: "#dd8800",
        dasharray: (edge) => {
          const w = Config.value(self2.normal.width, edge);
          return `${w * 1.5} ${w * 2}`;
        },
        linecap: (edge) => Config.value(self2.normal.linecap, edge),
        animate: (edge) => Config.value(self2.normal.animate, edge),
        animationSpeed: (edge) => Config.value(self2.normal.animationSpeed, edge)
      },
      selectable: false,
      gap: 3,
      type: "straight",
      marker: {
        source: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        },
        target: {
          type: "none",
          width: 5,
          height: 5,
          margin: -1,
          units: "strokeWidth",
          color: null
        }
      },
      margin: null,
      summarize: (_edges, configs) => {
        return configs.edge.type == "curve" ? false : null;
      },
      summarized: {
        label: {
          fontSize: 10,
          lineHeight: 1,
          color: "#4466cc"
        },
        shape: {
          type: "rect",
          radius: 6,
          width: 12,
          height: 12,
          borderRadius: 3,
          color: "#ffffff",
          strokeWidth: 1,
          strokeColor: "#4466cc",
          strokeDasharray: void 0
        },
        stroke: {
          width: 5,
          color: "#4466cc",
          dasharray: void 0,
          linecap: void 0,
          animate: false,
          animationSpeed: 50
        }
      },
      keepOrder: "clock",
      label: {
        fontFamily: void 0,
        fontSize: 11,
        lineHeight: 1.1,
        color: "#000000",
        background: void 0,
        margin: 4,
        padding: 4
      }
    })),
    path: {
      visible: false,
      clickable: false,
      curveInNode: false,
      end: "centerOfNode",
      margin: 0,
      path: {
        width: 6,
        color: (p) => {
          const list = [
            "#d5000088",
            "#c5116288",
            "#aa00ff88",
            "#6200ea88",
            "#304ffe88",
            "#2962ff88",
            "#0091ea88",
            "#00b8d488",
            "#00bfa588",
            "#00c85388",
            "#64dd1788",
            "#aeea0088",
            "#ffd60088",
            "#ffab0088",
            "#ff6d0088",
            "#dd2c0088"
          ];
          const hash = p.edges.map((s) => s.split("").reduce((a, b) => {
            a = (a << 5) - a + b.charCodeAt(0);
            return a & a;
          }, 0)).reduce((a, b) => a + b, 0);
          return list[Math.abs(hash) % list.length];
        },
        dasharray: void 0,
        linecap: "round",
        linejoin: "round",
        animate: false,
        animationSpeed: 50
      },
      transition: void 0
    }
  };
}
function getFullConfigs(config) {
  const configs = getConfigDefaults();
  if (config) {
    merge$1(configs, config);
  }
  return configs;
}
const injectionKey = Symbol("style");
function provideConfigs(configs) {
  const results = reactive(getConfigDefaults());
  const styleKeys = Object.keys(results);
  for (const key of styleKeys) {
    watch(() => configs[key], () => {
      merge$1(results[key], configs[key] || {});
    }, { immediate: true, deep: true });
  }
  provide(injectionKey, results);
  return results;
}
function injectConfig(key) {
  return nonNull(inject(injectionKey), `Configs(${key})`)[key];
}
function useViewConfig() {
  return injectConfig("view");
}
function useNodeConfig() {
  return injectConfig("node");
}
function useEdgeConfig() {
  return injectConfig("edge");
}
function usePathConfig() {
  return injectConfig("path");
}
const markers = reactive({});
const referenceCount = {};
const markersKey = Symbol("markers");
function provideMarkers() {
  provide(markersKey, markers);
  return markers;
}
function toHeadMarker(marker, isSource, strokeColor) {
  var _a;
  return __spreadProps(__spreadValues({}, marker), {
    color: (_a = marker.color) != null ? _a : strokeColor,
    isSource
  });
}
function buildKey(m) {
  return `marker_${m.type}_${m.width}_${m.height}_${m.margin}_${m.color.replace("#", "")}_${m.isSource ? "L" : "R"}_${m.units === "strokeWidth" ? "rel" : "abs"}`;
}
function addMarker(key, marker) {
  var _a;
  const m = (_a = referenceCount[key]) != null ? _a : 0;
  referenceCount[key] = m + 1;
  if (!m) {
    markers[key] = marker;
  }
}
function removeMarker(key) {
  var _a;
  const m = (_a = referenceCount[key]) != null ? _a : 0;
  if (m) {
    if (m - 1 === 0) {
      delete markers[key];
      delete referenceCount[key];
    } else {
      referenceCount[key] = m - 1;
    }
  }
}
function clearMarker(id) {
  if (id) {
    removeMarker(id);
  }
}
function makeMarker(marker, isSource, previousId, strokeColor) {
  if (marker.type === "none") {
    clearMarker(previousId);
    return void 0;
  }
  if (marker.type === "custom") {
    clearMarker(previousId);
    return marker.customId;
  }
  const headMarker = toHeadMarker(marker, isSource, strokeColor);
  const id = buildKey(headMarker);
  if (id === previousId) {
    return id;
  }
  clearMarker(previousId);
  addMarker(id, headMarker);
  return id;
}
function makeEdgeGroupStates(nodes, edges, configs) {
  const state = Reactive({
    edgeLayoutPoints: {},
    edgeGroups: {},
    summarizedEdges: {}
  });
  watchEffect(() => {
    const { edgeLayoutPoints, edgeGroups } = calculateEdgeGroupAndPositions(configs, nodes, edges);
    updateObjectDiff(state.edgeLayoutPoints, edgeLayoutPoints);
    updateObjectDiff(state.edgeGroups, edgeGroups);
  });
  watchEffect(() => {
    const summarizedEdges = {};
    for (const [id, { edges: edges2, groupWidth }] of Object.entries(state.edgeGroups)) {
      let summarize = false;
      if (groupWidth == 0) {
        summarize = false;
      } else if (configs.edge.summarize instanceof Function) {
        const s = configs.edge.summarize(edges2, configs);
        if (s === null) {
          summarize = defaultCheckSummarize(nodes, edges2, configs, groupWidth);
        } else {
          summarize = s;
        }
      } else if (configs.edge.summarize) {
        summarize = defaultCheckSummarize(nodes, edges2, configs, groupWidth);
      } else {
        summarize = false;
      }
      state.edgeGroups[id].summarize = summarize;
      if (summarize) {
        Object.keys(edges2).forEach((id2) => summarizedEdges[id2] = true);
      }
    }
    updateObjectDiff(state.summarizedEdges, summarizedEdges);
  });
  return state;
}
function calculateEdgeShiftedPosition(p, isSummarized, source, target, scale, keepOrder) {
  if (!p) {
    return { x1: 0, y1: 0, x2: 0, y2: 0 };
  }
  if (isSummarized) {
    return calculateEdgePositionInner(p.edge, source, target, scale, 0, 0, keepOrder);
  } else {
    return calculateEdgePositionInner(p.edge, source, target, scale, p.groupWidth, p.pointInGroup, keepOrder);
  }
}
function calculateEdgeGroupAndPositions(configs, nodes, edges) {
  const edgeLayoutPoints = {};
  const edgeGroups = {};
  const map = {};
  for (const [id, edge] of Object.entries(edges)) {
    if (!(edge.source in nodes && edge.target in nodes)) {
      continue;
    }
    const key = [edge.source, edge.target].sort().join("<=>");
    const values = map[key] || {};
    values[id] = edge;
    map[key] = values;
  }
  const calcGap = configs.edge.gap instanceof Function ? configs.edge.gap : (_e, _c) => configs.edge.gap;
  for (const [key, edges2] of Object.entries(map)) {
    const edgeLen = Object.keys(edges2).length;
    if (edgeLen == 0)
      continue;
    const gap = calcGap(edges2, configs);
    const [edgeId, edge] = Object.entries(edges2)[0];
    if (edgeLen === 1) {
      edgeLayoutPoints[edgeId] = { edge, pointInGroup: 0, groupWidth: 0 };
      edgeGroups[key] = { edges: edges2, groupWidth: 0, summarize: false };
    } else {
      let pointInGroup = 0;
      const lineHalfWidths = Object.values(edges2).map((edge2) => {
        return Config.value(configs.edge.normal.width, edge2) / 2;
      });
      const points = Object.entries(edges2).map(([edgeId2, edge2], i) => {
        if (i > 0) {
          pointInGroup += lineHalfWidths[i - 1] + gap + lineHalfWidths[i];
        }
        return [edgeId2, edge2, pointInGroup];
      });
      const groupWidth = pointInGroup;
      points.forEach(([edgeId2, edge2, pointInGroup2]) => {
        edgeLayoutPoints[edgeId2] = { edge: edge2, pointInGroup: pointInGroup2, groupWidth };
      });
      edgeGroups[key] = { edges: edges2, groupWidth, summarize: false };
    }
  }
  return { edgeLayoutPoints, edgeGroups };
}
function defaultCheckSummarize(nodes, edges, configs, width) {
  const edgeCount = Object.entries(edges).length;
  if (edgeCount === 1)
    return false;
  const minWidth = Math.min(...Object.values(edges).flatMap((e) => [nodes[e.source], nodes[e.target]]).filter((v) => v).map((node) => {
    const shape = Config.values(configs.node.normal, node);
    if (shape.type === "circle") {
      return shape.radius * 2;
    } else {
      return Math.min(shape.width, shape.height);
    }
  }));
  return width > minWidth;
}
function calculateEdgePositionInner(edge, source, target, scale, groupWidth, pointInGroup, keepOrder) {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  let x1, y1, x2, y2;
  if (edge.source < edge.target) {
    [x1, y1, x2, y2] = calculateLinePosition((_a = source == null ? void 0 : source.x) != null ? _a : 0, (_b = source == null ? void 0 : source.y) != null ? _b : 0, (_c = target == null ? void 0 : target.x) != null ? _c : 0, (_d = target == null ? void 0 : target.y) != null ? _d : 0, scale, groupWidth, pointInGroup, keepOrder);
  } else {
    [x2, y2, x1, y1] = calculateLinePosition((_e = target == null ? void 0 : target.x) != null ? _e : 0, (_f = target == null ? void 0 : target.y) != null ? _f : 0, (_g = source == null ? void 0 : source.x) != null ? _g : 0, (_h = source == null ? void 0 : source.y) != null ? _h : 0, scale, groupWidth, pointInGroup, keepOrder);
  }
  return { x1, y1, x2, y2 };
}
function calculateLinePosition(x1, y1, x2, y2, scale, groupWidth, pointInGroup, keepOrder) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  let diff = (groupWidth / 2 - pointInGroup) * scale;
  if (diff !== 0 && keepOrder !== "clock") {
    const radian = Math.atan2(y2 - y1, x2 - x1);
    if (keepOrder === "vertical") {
      const perpendicular = Math.PI / 2;
      if (radian < -perpendicular || radian >= perpendicular) {
        diff *= -1;
      }
    } else if (keepOrder === "horizontal") {
      if (radian < 0) {
        diff *= -1;
      }
    }
  }
  if (dx === 0) {
    const sign = dy < 0 ? -1 : 1;
    return [x1 + diff * sign, y1, x2 + diff * sign, y2];
  } else if (dy === 0) {
    const sign = dx < 0 ? 1 : -1;
    return [x1, y1 + diff * sign, x2, y2 + diff * sign];
  } else {
    const slope = dy / dx;
    const moveSlope = -1 / slope;
    if (dy < 0) {
      diff = -diff;
    }
    const diffX = diff / Math.sqrt(1 + Math.pow(moveSlope, 2));
    return [x1 + diffX, y1 + diffX * moveSlope, x2 + diffX, y2 + diffX * moveSlope];
  }
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var victor = { exports: {} };
(function(module2, exports2) {
  module2.exports = Victor;
  function Victor(x, y) {
    if (!(this instanceof Victor)) {
      return new Victor(x, y);
    }
    this.x = x || 0;
    this.y = y || 0;
  }
  Victor.fromArray = function(arr) {
    return new Victor(arr[0] || 0, arr[1] || 0);
  };
  Victor.fromObject = function(obj) {
    return new Victor(obj.x || 0, obj.y || 0);
  };
  Victor.prototype.addX = function(vec) {
    this.x += vec.x;
    return this;
  };
  Victor.prototype.addY = function(vec) {
    this.y += vec.y;
    return this;
  };
  Victor.prototype.add = function(vec) {
    this.x += vec.x;
    this.y += vec.y;
    return this;
  };
  Victor.prototype.addScalar = function(scalar) {
    this.x += scalar;
    this.y += scalar;
    return this;
  };
  Victor.prototype.addScalarX = function(scalar) {
    this.x += scalar;
    return this;
  };
  Victor.prototype.addScalarY = function(scalar) {
    this.y += scalar;
    return this;
  };
  Victor.prototype.subtractX = function(vec) {
    this.x -= vec.x;
    return this;
  };
  Victor.prototype.subtractY = function(vec) {
    this.y -= vec.y;
    return this;
  };
  Victor.prototype.subtract = function(vec) {
    this.x -= vec.x;
    this.y -= vec.y;
    return this;
  };
  Victor.prototype.subtractScalar = function(scalar) {
    this.x -= scalar;
    this.y -= scalar;
    return this;
  };
  Victor.prototype.subtractScalarX = function(scalar) {
    this.x -= scalar;
    return this;
  };
  Victor.prototype.subtractScalarY = function(scalar) {
    this.y -= scalar;
    return this;
  };
  Victor.prototype.divideX = function(vector) {
    this.x /= vector.x;
    return this;
  };
  Victor.prototype.divideY = function(vector) {
    this.y /= vector.y;
    return this;
  };
  Victor.prototype.divide = function(vector) {
    this.x /= vector.x;
    this.y /= vector.y;
    return this;
  };
  Victor.prototype.divideScalar = function(scalar) {
    if (scalar !== 0) {
      this.x /= scalar;
      this.y /= scalar;
    } else {
      this.x = 0;
      this.y = 0;
    }
    return this;
  };
  Victor.prototype.divideScalarX = function(scalar) {
    if (scalar !== 0) {
      this.x /= scalar;
    } else {
      this.x = 0;
    }
    return this;
  };
  Victor.prototype.divideScalarY = function(scalar) {
    if (scalar !== 0) {
      this.y /= scalar;
    } else {
      this.y = 0;
    }
    return this;
  };
  Victor.prototype.invertX = function() {
    this.x *= -1;
    return this;
  };
  Victor.prototype.invertY = function() {
    this.y *= -1;
    return this;
  };
  Victor.prototype.invert = function() {
    this.invertX();
    this.invertY();
    return this;
  };
  Victor.prototype.multiplyX = function(vector) {
    this.x *= vector.x;
    return this;
  };
  Victor.prototype.multiplyY = function(vector) {
    this.y *= vector.y;
    return this;
  };
  Victor.prototype.multiply = function(vector) {
    this.x *= vector.x;
    this.y *= vector.y;
    return this;
  };
  Victor.prototype.multiplyScalar = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  };
  Victor.prototype.multiplyScalarX = function(scalar) {
    this.x *= scalar;
    return this;
  };
  Victor.prototype.multiplyScalarY = function(scalar) {
    this.y *= scalar;
    return this;
  };
  Victor.prototype.normalize = function() {
    var length = this.length();
    if (length === 0) {
      this.x = 1;
      this.y = 0;
    } else {
      this.divide(Victor(length, length));
    }
    return this;
  };
  Victor.prototype.norm = Victor.prototype.normalize;
  Victor.prototype.limit = function(max, factor) {
    if (Math.abs(this.x) > max) {
      this.x *= factor;
    }
    if (Math.abs(this.y) > max) {
      this.y *= factor;
    }
    return this;
  };
  Victor.prototype.randomize = function(topLeft, bottomRight) {
    this.randomizeX(topLeft, bottomRight);
    this.randomizeY(topLeft, bottomRight);
    return this;
  };
  Victor.prototype.randomizeX = function(topLeft, bottomRight) {
    var min = Math.min(topLeft.x, bottomRight.x);
    var max = Math.max(topLeft.x, bottomRight.x);
    this.x = random(min, max);
    return this;
  };
  Victor.prototype.randomizeY = function(topLeft, bottomRight) {
    var min = Math.min(topLeft.y, bottomRight.y);
    var max = Math.max(topLeft.y, bottomRight.y);
    this.y = random(min, max);
    return this;
  };
  Victor.prototype.randomizeAny = function(topLeft, bottomRight) {
    if (!!Math.round(Math.random())) {
      this.randomizeX(topLeft, bottomRight);
    } else {
      this.randomizeY(topLeft, bottomRight);
    }
    return this;
  };
  Victor.prototype.unfloat = function() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  };
  Victor.prototype.toFixed = function(precision) {
    if (typeof precision === "undefined") {
      precision = 8;
    }
    this.x = this.x.toFixed(precision);
    this.y = this.y.toFixed(precision);
    return this;
  };
  Victor.prototype.mixX = function(vec, amount) {
    if (typeof amount === "undefined") {
      amount = 0.5;
    }
    this.x = (1 - amount) * this.x + amount * vec.x;
    return this;
  };
  Victor.prototype.mixY = function(vec, amount) {
    if (typeof amount === "undefined") {
      amount = 0.5;
    }
    this.y = (1 - amount) * this.y + amount * vec.y;
    return this;
  };
  Victor.prototype.mix = function(vec, amount) {
    this.mixX(vec, amount);
    this.mixY(vec, amount);
    return this;
  };
  Victor.prototype.clone = function() {
    return new Victor(this.x, this.y);
  };
  Victor.prototype.copyX = function(vec) {
    this.x = vec.x;
    return this;
  };
  Victor.prototype.copyY = function(vec) {
    this.y = vec.y;
    return this;
  };
  Victor.prototype.copy = function(vec) {
    this.copyX(vec);
    this.copyY(vec);
    return this;
  };
  Victor.prototype.zero = function() {
    this.x = this.y = 0;
    return this;
  };
  Victor.prototype.dot = function(vec2) {
    return this.x * vec2.x + this.y * vec2.y;
  };
  Victor.prototype.cross = function(vec2) {
    return this.x * vec2.y - this.y * vec2.x;
  };
  Victor.prototype.projectOnto = function(vec2) {
    var coeff = (this.x * vec2.x + this.y * vec2.y) / (vec2.x * vec2.x + vec2.y * vec2.y);
    this.x = coeff * vec2.x;
    this.y = coeff * vec2.y;
    return this;
  };
  Victor.prototype.horizontalAngle = function() {
    return Math.atan2(this.y, this.x);
  };
  Victor.prototype.horizontalAngleDeg = function() {
    return radian2degrees(this.horizontalAngle());
  };
  Victor.prototype.verticalAngle = function() {
    return Math.atan2(this.x, this.y);
  };
  Victor.prototype.verticalAngleDeg = function() {
    return radian2degrees(this.verticalAngle());
  };
  Victor.prototype.angle = Victor.prototype.horizontalAngle;
  Victor.prototype.angleDeg = Victor.prototype.horizontalAngleDeg;
  Victor.prototype.direction = Victor.prototype.horizontalAngle;
  Victor.prototype.rotate = function(angle) {
    var nx = this.x * Math.cos(angle) - this.y * Math.sin(angle);
    var ny = this.x * Math.sin(angle) + this.y * Math.cos(angle);
    this.x = nx;
    this.y = ny;
    return this;
  };
  Victor.prototype.rotateDeg = function(angle) {
    angle = degrees2radian(angle);
    return this.rotate(angle);
  };
  Victor.prototype.rotateTo = function(rotation) {
    return this.rotate(rotation - this.angle());
  };
  Victor.prototype.rotateToDeg = function(rotation) {
    rotation = degrees2radian(rotation);
    return this.rotateTo(rotation);
  };
  Victor.prototype.rotateBy = function(rotation) {
    var angle = this.angle() + rotation;
    return this.rotate(angle);
  };
  Victor.prototype.rotateByDeg = function(rotation) {
    rotation = degrees2radian(rotation);
    return this.rotateBy(rotation);
  };
  Victor.prototype.distanceX = function(vec) {
    return this.x - vec.x;
  };
  Victor.prototype.absDistanceX = function(vec) {
    return Math.abs(this.distanceX(vec));
  };
  Victor.prototype.distanceY = function(vec) {
    return this.y - vec.y;
  };
  Victor.prototype.absDistanceY = function(vec) {
    return Math.abs(this.distanceY(vec));
  };
  Victor.prototype.distance = function(vec) {
    return Math.sqrt(this.distanceSq(vec));
  };
  Victor.prototype.distanceSq = function(vec) {
    var dx = this.distanceX(vec), dy = this.distanceY(vec);
    return dx * dx + dy * dy;
  };
  Victor.prototype.length = function() {
    return Math.sqrt(this.lengthSq());
  };
  Victor.prototype.lengthSq = function() {
    return this.x * this.x + this.y * this.y;
  };
  Victor.prototype.magnitude = Victor.prototype.length;
  Victor.prototype.isZero = function() {
    return this.x === 0 && this.y === 0;
  };
  Victor.prototype.isEqualTo = function(vec2) {
    return this.x === vec2.x && this.y === vec2.y;
  };
  Victor.prototype.toString = function() {
    return "x:" + this.x + ", y:" + this.y;
  };
  Victor.prototype.toArray = function() {
    return [this.x, this.y];
  };
  Victor.prototype.toObject = function() {
    return { x: this.x, y: this.y };
  };
  var degrees = 180 / Math.PI;
  function random(min, max) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  function radian2degrees(rad) {
    return rad * degrees;
  }
  function degrees2radian(deg) {
    return deg / degrees;
  }
})(victor);
var Vector = victor.exports;
function fromLinePosition(line) {
  const source = Vector.fromArray([line.x1, line.y1]);
  const target = Vector.fromArray([line.x2, line.y2]);
  return {
    source,
    target,
    v: toLineVector(source, target)
  };
}
function fromPositions(sourcePos, targetPos) {
  const source = Vector.fromObject(sourcePos);
  const target = Vector.fromObject(targetPos);
  return {
    source,
    target,
    v: toLineVector(source, target)
  };
}
function fromVectors(source, target) {
  return {
    source,
    target,
    v: toLineVector(source, target)
  };
}
function toLineVector(source, target) {
  return target.clone().subtract(source);
}
function toVectorsFromLinePosition(line) {
  return [Vector.fromArray([line.x1, line.y1]), Vector.fromArray([line.x2, line.y2])];
}
function getCenterOfLinePosition(line) {
  return Vector.fromArray([(line.x1 + line.x2) / 2, (line.y1 + line.y2) / 2]);
}
function getNearestPoint(p, line) {
  const n = line.v.clone().normalize();
  const lp = line.source;
  const a = p.clone().subtract(lp);
  const dot = n.dot(a);
  const near = lp.clone().add(n.multiplyScalar(dot));
  return near;
}
function getIntersectionOfLineTargetAndCircle(source, target, center, radius) {
  const p = target.clone();
  const length = p.subtract(center).lengthSq();
  const contains = length - radius * radius <= Math.pow(1, -10);
  if (!contains)
    return null;
  const line = fromVectors(source, target);
  const h = getNearestPoint(center, line);
  const hp = h.clone().subtract(center);
  const hpLen = hp.length();
  if (radius < hpLen)
    return null;
  if (radius === hpLen)
    return h;
  const t = Math.sqrt(__pow(radius, 2) - __pow(hpLen, 2));
  const tv = line.v.normalize().multiplyScalar(t);
  return h.subtract(tv);
}
function getIntersectionOfLineTargetAndCircle2(source, target, center, radius, nearBy) {
  const p = target.clone();
  const length = p.subtract(center).lengthSq();
  const contains = length - radius * radius <= Math.pow(1, -10);
  if (!contains)
    return null;
  const line = fromVectors(source, target);
  const h = getNearestPoint(center, line);
  const hp = h.clone().subtract(center);
  const hpLen = hp.length();
  if (radius < hpLen)
    return null;
  if (radius === hpLen)
    return h;
  const t = Math.sqrt(__pow(radius, 2) - __pow(hpLen, 2));
  const tv = line.v.normalize().multiplyScalar(t);
  const ip1 = h.clone().add(tv);
  const ip2 = h.clone().subtract(tv);
  const d1 = calculateDistance(nearBy, ip1);
  const d2 = calculateDistance(nearBy, ip2);
  if (Math.abs(d1 - d2) < 2) {
    return ip2;
  }
  return d1 < d2 ? ip1 : ip2;
}
function getIntersectionPointOfLines(line1, line2) {
  const p2 = line2.source;
  const v = p2.clone().subtract(line1.source);
  const v1 = line1.v;
  const v2 = line2.v;
  const t2 = v.cross(v1) / v1.cross(v2);
  return p2.clone().add(v2.clone().multiplyScalar(t2));
}
function getIntersectionOfCircles(center1, radius1, center2, radius2, near) {
  const c1 = center1;
  const c2 = center2;
  const vC1C2 = c2.clone().subtract(c1);
  const a = vC1C2.magnitude();
  const sumR = radius1 + radius2;
  if (sumR < a)
    return null;
  const subR = Math.abs(radius1 - radius2);
  if (a < subR)
    return null;
  if (a === sumR) {
    const n = vC1C2.clone().normalize();
    const p = center1.clone().add(n.multiplyScalar(radius1));
    return p;
  }
  if (a === subR) {
    const n = vC1C2.clone().normalize();
    const isLarge = radius1 > radius2;
    const p = center1.clone().add(n.multiplyScalar(isLarge ? radius1 : -radius1));
    return p;
  }
  const b = radius1;
  const c = radius2;
  const cos = (__pow(a, 2) + __pow(b, 2) - __pow(c, 2)) / (2 * a * b);
  const rc = b * cos;
  const rs = Math.sqrt(__pow(b, 2) - __pow(rc, 2));
  const n1 = vC1C2.clone().normalize();
  const n2 = Vector.fromArray([-n1.y, n1.x]);
  const tn1 = n1.clone().multiplyScalar(rc);
  const sn2 = n2.clone().multiplyScalar(rs);
  const result1 = center1.clone().add(tn1).add(sn2);
  const result2 = center1.clone().add(tn1).subtract(sn2);
  const d1 = calculateDistance(result1, near);
  const d2 = calculateDistance(result2, near);
  return d1 < d2 ? result1 : result2;
}
function calculatePerpendicularLine(line) {
  const n1 = line.v.clone().normalize().rotate(Math.PI / 2);
  return fromVectors(line.target, line.target.clone().add(n1));
}
function calculateRelativeAngleRadian(line1, line2) {
  return Math.atan2(line1.v.y * line2.v.x - line1.v.x * line2.v.y, line1.v.x * line2.v.x + line1.v.y * line2.v.y);
}
function calculateCircleCenterAndRadiusBy3Points(p1, p2, p3) {
  const x1 = p1.x;
  const y1 = p1.y;
  const x2 = p2.x;
  const y2 = p2.y;
  const x3 = p3.x;
  const y3 = p3.y;
  const x12 = x1 - x2;
  const y12 = y1 - y2;
  const x32 = x3 - x2;
  const y32 = y3 - y2;
  const x = (y32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) - y12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) / (2 * x12 * y32 - 2 * y12 * x32);
  const y = (-x32 * (x12 * (x1 + x2) + y12 * (y1 + y2)) + x12 * (x32 * (x3 + x2) + y32 * (y3 + y2))) / (2 * x12 * y32 - 2 * y12 * x32);
  const radius = Math.sqrt(Math.pow(x1 - x, 2) + Math.pow(y1 - y, 2));
  const center = Vector.fromArray([x, y]);
  return [center, radius];
}
function calculateDistance(pos1, pos2) {
  const x = pos2.x - pos1.x;
  const y = pos2.y - pos1.y;
  return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
}
function baseExtremum(array, iteratee, comparator) {
  var index = -1, length = array.length;
  while (++index < length) {
    var value = array[index], current = iteratee(value);
    if (current != null && (computed2 === void 0 ? current === current && !isSymbol(current) : comparator(current, computed2))) {
      var computed2 = current, result = value;
    }
  }
  return result;
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject(value);
}
function getMatchData(object) {
  var result = keys(object), length = result.length;
  while (length--) {
    var key = result[length], value = object[key];
    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
var stringToPath$1 = stringToPath;
function castPath(value, object) {
  if (isArray$1(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath$1(toString(value));
}
var INFINITY = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index = 0, length = path.length;
  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : void 0;
}
function get(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments$1(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function baseLt(value, other) {
  return value < other;
}
function minBy(array, iteratee) {
  return array && array.length ? baseExtremum(array, baseIteratee(iteratee), baseLt) : void 0;
}
function positionsToLinePosition(p1, p2) {
  return { x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y };
}
function calculateDistanceToAvoidOverlapsWithRect(sourcePos, targetPos, rect, scale) {
  var _a;
  const centerLine = fromPositions(sourcePos, targetPos);
  const left = targetPos.x - rect.width / 2 * scale;
  const top = targetPos.y - rect.height / 2 * scale;
  const right = targetPos.x + rect.width / 2 * scale;
  const bottom = targetPos.y + rect.height / 2 * scale;
  const vertexes = [];
  const borderRadius = rect.borderRadius * scale;
  if (borderRadius == 0) {
    vertexes.push(Vector.fromArray([left, top]), Vector.fromArray([left, bottom]), Vector.fromArray([right, top]), Vector.fromArray([right, bottom]));
  } else {
    const hypo = borderRadius * Math.sin(Math.PI / 4);
    vertexes.push(Vector.fromArray([left + borderRadius, top]), Vector.fromArray([left, top + borderRadius]), Vector.fromArray([left + borderRadius - hypo, top + borderRadius - hypo]), Vector.fromArray([left + borderRadius, bottom]), Vector.fromArray([left, bottom - borderRadius]), Vector.fromArray([left + borderRadius - hypo, bottom - borderRadius + hypo]), Vector.fromArray([right - borderRadius, top]), Vector.fromArray([right, top + borderRadius]), Vector.fromArray([right - borderRadius + hypo, top + borderRadius - hypo]), Vector.fromArray([right - borderRadius, bottom]), Vector.fromArray([right, bottom - borderRadius]), Vector.fromArray([right - borderRadius + hypo, bottom - borderRadius + hypo]));
  }
  const hits = vertexes.map((p) => getNearestPoint(p, centerLine));
  const minP = (_a = minBy(hits, (p) => toLineVector(centerLine.source, p).lengthSq())) != null ? _a : centerLine.target;
  return toLineVector(minP, centerLine.target).length();
}
function calculateEdgeLabelArea(linePos, edgeStyle, margin, padding, scale) {
  const line = fromLinePosition(linePos);
  const normalized = line.v.clone().normalize();
  const sv = padding === 0 ? line.source : line.source.clone().add(normalized.clone().multiplyScalar(padding * scale));
  const tv = padding === 0 ? line.target : line.target.clone().subtract(normalized.clone().multiplyScalar(padding * scale));
  const labelMargin = (edgeStyle.width / 2 + margin) * scale;
  const vMargin = Vector.fromArray([-normalized.y, normalized.x]).multiplyScalar(labelMargin);
  let sourceAbove = sv.clone().subtract(vMargin).toObject();
  let sourceBelow = sv.clone().add(vMargin).toObject();
  let targetAbove = tv.clone().subtract(vMargin).toObject();
  let targetBelow = tv.clone().add(vMargin).toObject();
  const angle = line.v.angleDeg();
  if (angle < -90 || angle >= 90) {
    [sourceAbove, sourceBelow] = [sourceBelow, sourceAbove];
    [targetAbove, targetBelow] = [targetBelow, targetAbove];
  }
  return {
    source: { above: sourceAbove, below: sourceBelow },
    target: { above: targetAbove, below: targetBelow }
  };
}
function calculateDistancesFromCenterOfNodeToEndOfNode(sourceNodePos, targetNodePos, sourceNodeShape, targetNodeShape) {
  let distance1;
  if (sourceNodeShape.type === "circle") {
    distance1 = sourceNodeShape.radius;
  } else {
    distance1 = calculateDistanceToAvoidOverlapsWithRect(targetNodePos, sourceNodePos, sourceNodeShape, 1);
  }
  let distance2;
  if (targetNodeShape.type === "circle") {
    distance2 = targetNodeShape.radius;
  } else {
    distance2 = calculateDistanceToAvoidOverlapsWithRect(sourceNodePos, targetNodePos, targetNodeShape, 1);
  }
  return [distance1, distance2];
}
function applyMarginToLine(linePos, sourceMargin, targetMargin) {
  const line = fromLinePosition(linePos);
  return applyMarginToLineInner(line, sourceMargin, targetMargin);
}
function applyMarginToLineInner(line, sourceMargin, targetMargin) {
  const normalized = line.v.clone().normalize();
  line.v.angle();
  const sv = line.source.clone().add(normalized.clone().multiplyScalar(sourceMargin));
  const tv = line.target.clone().subtract(normalized.clone().multiplyScalar(targetMargin));
  let [x1, y1] = sv.toArray();
  let [x2, y2] = tv.toArray();
  const check = toLineVector(sv, tv);
  if (line.v.angle() * check.angle() < 0) {
    const c1 = Vector.fromArray([(x1 + x2) / 2, (y1 + y2) / 2]);
    const c2 = c1.clone().add(normalized.multiplyScalar(0.5));
    [x1, y1] = c1.toArray();
    [x2, y2] = c2.toArray();
  }
  return { x1, y1, x2, y2 };
}
function moveOnCircumference(pos, center, radian) {
  const { x, y } = pos;
  const dx = x - center.x;
  const dy = y - center.y;
  return {
    x: dx * Math.cos(radian) - dy * Math.sin(radian) + center.x,
    y: dx * Math.sin(radian) + dy * Math.cos(radian) + center.y
  };
}
function reverseAngleRadian(theta) {
  if (theta > 0) {
    return -(Math.PI * 2 - theta);
  } else {
    return Math.PI * 2 + theta;
  }
}
function inverseLine(line) {
  return {
    x1: line.x2,
    y1: line.y2,
    x2: line.x1,
    y2: line.y1
  };
}
function calculateBezierCurveControlPoint(p1, center, p2, theta0) {
  const control = [];
  const centerToSource = fromVectors(center, p1);
  const centerToTarget = fromVectors(center, p2);
  let theta = calculateRelativeAngleRadian(centerToSource, centerToTarget);
  if (theta0 * theta < 0) {
    theta = reverseAngleRadian(theta);
  }
  const middle = Vector.fromObject(moveOnCircumference(p1, center, -theta / 2));
  const centerToMp = fromVectors(center, middle);
  const mpTangent = calculatePerpendicularLine(centerToMp);
  const theta1 = calculateRelativeAngleRadian(centerToSource, centerToMp);
  let tangent = calculatePerpendicularLine(centerToSource);
  if (Math.abs(theta1) < Math.PI / 2) {
    const cp = getIntersectionPointOfLines(tangent, mpTangent);
    control.push(cp);
  } else {
    const mp = Vector.fromObject(moveOnCircumference(middle, center, theta1 / 2));
    const tangent2 = calculatePerpendicularLine(fromVectors(center, Vector.fromObject(mp)));
    const cp1 = getIntersectionPointOfLines(tangent, tangent2);
    const cp2 = getIntersectionPointOfLines(tangent2, mpTangent);
    control.push(cp1, mp, cp2);
  }
  control.push(middle);
  const theta2 = calculateRelativeAngleRadian(centerToTarget, centerToMp);
  tangent = calculatePerpendicularLine(centerToTarget);
  if (Math.abs(theta2) < Math.PI / 2) {
    const cp = getIntersectionPointOfLines(tangent, mpTangent);
    control.push(cp);
  } else {
    const mp = Vector.fromObject(moveOnCircumference(middle, center, theta2 / 2));
    const tangent2 = calculatePerpendicularLine(fromVectors(center, Vector.fromObject(mp)));
    const cp1 = getIntersectionPointOfLines(mpTangent, tangent2);
    const cp2 = getIntersectionPointOfLines(tangent2, tangent);
    control.push(cp1, mp, cp2);
  }
  return control;
}
const statesKey = Symbol("states");
const NONE_MARKER = {
  type: "none",
  width: 0,
  height: 0,
  margin: 0,
  units: "strokeWidth",
  color: null
};
function provideStates(nodes, edges, selectedNodes, selectedEdges, hoveredNodes, hoveredEdges, configs, layouts, scale) {
  const nodeStates = reactive({});
  const edgeStates = reactive({});
  Object.keys(nodes).forEach((id) => {
    createNodeState(nodeStates, nodes, id, selectedNodes.has(id), false, configs.node);
  });
  watch(() => [...selectedNodes], (nodes2, prev) => {
    const append = nodes2.filter((n) => !prev.includes(n));
    const removed = prev.filter((n) => !nodes2.includes(n));
    append.forEach((id) => {
      const state = nodeStates[id];
      if (state && !state.selected)
        state.selected = true;
    });
    removed.forEach((id) => {
      const state = nodeStates[id];
      if (state && state.selected)
        state.selected = false;
    });
  });
  watch(() => [...hoveredNodes], (nodes2, prev) => {
    const append = nodes2.filter((n) => !prev.includes(n));
    const removed = prev.filter((n) => !nodes2.includes(n));
    append.forEach((id) => {
      const state = nodeStates[id];
      if (state && !state.hovered)
        state.hovered = true;
    });
    removed.forEach((id) => {
      const state = nodeStates[id];
      if (state && state.hovered)
        state.hovered = false;
    });
  });
  watch(() => new Set(Object.keys(nodes)), (idSet, prev) => {
    for (const nodeId of idSet) {
      if (prev.has(nodeId))
        continue;
      createNodeState(nodeStates, nodes, nodeId, false, false, configs.node);
    }
    const positions = layouts.nodes;
    for (const nodeId of prev) {
      if (idSet.has(nodeId))
        continue;
      delete positions[nodeId];
      selectedNodes.delete(nodeId);
      hoveredNodes.delete(nodeId);
      delete nodeStates[nodeId];
    }
  });
  const edgeGroupStates = makeEdgeGroupStates(nodes, edges, configs);
  Object.keys(edges).forEach((id) => {
    createEdgeState(edgeStates, edgeGroupStates, nodeStates, edges, id, selectedEdges.has(id), configs.edge, layouts.nodes, scale);
  });
  watch(() => [...selectedEdges], (nodes2, prev) => {
    const append = nodes2.filter((n) => !prev.includes(n));
    const removed = prev.filter((n) => !nodes2.includes(n));
    append.forEach((id) => {
      const state = edgeStates[id];
      if (state && !state.selected)
        state.selected = true;
    });
    removed.forEach((id) => {
      const state = edgeStates[id];
      if (state && state.selected)
        state.selected = false;
    });
  });
  watch(() => [...hoveredEdges], (nodes2, prev) => {
    const append = nodes2.filter((n) => !prev.includes(n));
    const removed = prev.filter((n) => !nodes2.includes(n));
    append.forEach((id) => {
      const state = edgeStates[id];
      if (state && !state.hovered) {
        state.hovered = true;
      }
    });
    removed.forEach((id) => {
      const state = edgeStates[id];
      if (state && state.hovered) {
        state.hovered = false;
      }
    });
  });
  watch(() => new Set(Object.keys(edges)), (idSet, prev) => {
    for (const edgeId of idSet) {
      if (prev.has(edgeId))
        continue;
      createEdgeState(edgeStates, edgeGroupStates, nodeStates, edges, edgeId, false, configs.edge, layouts.nodes, scale);
    }
    for (const edgeId of prev) {
      if (idSet.has(edgeId))
        continue;
      selectedEdges.delete(edgeId);
      hoveredEdges.delete(edgeId);
      edgeStates[edgeId].stopWatchHandle();
      delete edgeStates[edgeId];
    }
  });
  const states = { nodeStates, edgeStates, edgeGroupStates, layouts };
  provide(statesKey, states);
  return states;
}
function useStates() {
  return nonNull(inject(statesKey), "states");
}
function getNodeShape(node, selected, hovered, config) {
  if (hovered && config.hover) {
    return Config.values(config.hover, node);
  } else {
    return getNodeStaticShape(node, selected, config);
  }
}
function getNodeStaticShape(node, selected, config) {
  if (selected && config.selected) {
    return Config.values(config.selected, node);
  } else {
    return Config.values(config.normal, node);
  }
}
function getEdgeStroke(edge, selected, hovered, config) {
  if (selected) {
    return Config.values(config.selected, edge);
  } else if (hovered && config.hover) {
    return Config.values(config.hover, edge);
  } else {
    return Config.values(config.normal, edge);
  }
}
function createNodeState(states, nodes, id, selected, hovered, config) {
  states[id] = { selected, hovered };
  const state = states[id];
  state.shape = computed(() => getNodeShape(nodes[id], state.selected, state.hovered, config));
  state.staticShape = computed(() => getNodeStaticShape(nodes[id], state.selected, config));
  state.label = computed(() => Config.values(config.label, nodes[id]));
  state.labelText = computed(() => {
    var _a, _b;
    if (config.label.text instanceof Function) {
      return unref(state.label).text;
    } else {
      return (_b = (_a = nodes[id]) == null ? void 0 : _a[unref(state.label).text]) != null ? _b : "";
    }
  });
  state.draggable = computed(() => Config.value(config.draggable, nodes[id]));
  state.selectable = computed(() => Config.value(config.selectable, nodes[id]));
}
function toEdgeMarker(marker) {
  if (marker.type === "none") {
    return NONE_MARKER;
  } else {
    return marker;
  }
}
function createEdgeState(states, groupStates, nodeStates, edges, id, selected, config, layouts, scale) {
  const edge = edges[id];
  if (!edge)
    return;
  states[id] = {
    line: void 0,
    selectable: false,
    selected,
    hovered: false,
    curve: void 0,
    origin: { x1: 0, y1: 0, x2: 0, y2: 0 },
    labelPosition: { x1: 0, y1: 0, x2: 0, y2: 0 },
    position: { x1: 0, y1: 0, x2: 0, y2: 0 },
    stopWatchHandle: () => {
    }
  };
  const state = states[id];
  const line = computed(() => {
    const edge2 = edges[id];
    const stroke = getEdgeStroke(edge2, state.selected, state.hovered, config);
    const normalWidth = Config.value(config.normal.width, edge2);
    const source = toEdgeMarker(Config.values(config.marker.source, [edge2, stroke]));
    const target = toEdgeMarker(Config.values(config.marker.target, [edge2, stroke]));
    return { stroke, normalWidth, source, target };
  });
  state.line = line;
  state.selectable = computed(() => Config.value(config.selectable, edges[id]));
  const edgeLayoutPoint = toRef(groupStates.edgeLayoutPoints, id);
  const isEdgeSummarized = toRef(groupStates.summarizedEdges, id);
  const stopCalcHandle = watchEffect(() => {
    var _a, _b;
    const edge2 = edges[id];
    if (!edge2)
      return;
    const source = layouts[edge2 == null ? void 0 : edge2.source];
    const target = layouts[edge2 == null ? void 0 : edge2.target];
    const sourceShape = (_a = nodeStates[edge2 == null ? void 0 : edge2.source]) == null ? void 0 : _a.staticShape;
    const targetShape = (_b = nodeStates[edge2 == null ? void 0 : edge2.target]) == null ? void 0 : _b.staticShape;
    if (!source || !target || !sourceShape || !targetShape) {
      return;
    }
    const shiftedPosition = calculateEdgeShiftedPosition(edgeLayoutPoint.value, isEdgeSummarized.value, source, target, scale.value, config.keepOrder);
    const [sourceShapeMargin, targetShapeMargin] = calculateDistancesFromCenterOfNodeToEndOfNode(source, target, sourceShape, targetShape);
    const s = scale.value;
    state.labelPosition = applyMarginToLine(shiftedPosition, sourceShapeMargin * s, targetShapeMargin * s);
    let sourceMargin = 0;
    let targetMargin = 0;
    const l = line.value;
    if (l.source.type !== "none") {
      const marker = l.source;
      sourceMargin = marker.margin + marker.width;
      if (marker.units === "strokeWidth") {
        sourceMargin *= l.normalWidth;
      }
    }
    if (l.target.type !== "none") {
      const marker = l.target;
      targetMargin = marker.margin + marker.width;
      if (marker.units === "strokeWidth") {
        targetMargin *= l.normalWidth;
      }
    }
    if (config.margin === null || config.margin === void 0) {
      if (l.source.type !== "none" || l.target.type !== "none") {
        sourceMargin += sourceShapeMargin;
        targetMargin += targetShapeMargin;
      }
    } else {
      sourceMargin += config.margin + sourceShapeMargin;
      targetMargin += config.margin + targetShapeMargin;
    }
    const type = config.type;
    if (type === "straight") {
      state.origin = shiftedPosition;
      state.curve = void 0;
      if (sourceMargin === 0 && targetMargin === 0) {
        state.position = state.origin;
      } else {
        state.position = applyMarginToLine(state.origin, sourceMargin * s, targetMargin * s);
      }
    } else {
      state.origin = positionsToLinePosition(source, target);
      const shift = edgeLayoutPoint.value.groupWidth / 2 - edgeLayoutPoint.value.pointInGroup;
      const [position, curve] = calculateCurvePositionAndState(state.origin, shiftedPosition, shift, sourceMargin * s, targetMargin * s);
      state.position = position;
      state.curve = curve;
    }
  });
  const stopUpdateMarkerHandle = watchEffect(() => {
    if (!edges[id])
      return;
    state.sourceMarkerId = makeMarker(line.value.source, true, state.sourceMarkerId, line.value.stroke.color);
    state.targetMarkerId = makeMarker(line.value.target, false, state.targetMarkerId, line.value.stroke.color);
  });
  states[id].stopWatchHandle = () => {
    stopCalcHandle();
    stopUpdateMarkerHandle();
    clearMarker(state.sourceMarkerId);
    clearMarker(state.targetMarkerId);
  };
}
function calculateCurvePositionAndState(originPosition, shiftedPosition, shift, sourceMargin, targetMargin) {
  const origin = fromLinePosition(originPosition);
  const shifted = fromLinePosition(shiftedPosition);
  const shiftedCenter = getCenterOfLinePosition(shiftedPosition);
  const [center, radius] = calculateCircleCenterAndRadiusBy3Points(origin.source, origin.target, shiftedCenter);
  let position;
  let curve = void 0;
  if (shift === 0) {
    if (sourceMargin === 0 && targetMargin === 0) {
      position = originPosition;
    } else {
      position = applyMarginToLine(originPosition, sourceMargin, targetMargin);
    }
    return [position, curve];
  }
  const centerToTop = fromVectors(center, shiftedCenter);
  const theta0 = calculateRelativeAngleRadian(fromVectors(center, origin.source), centerToTop);
  if (sourceMargin === 0 && targetMargin === 0) {
    position = originPosition;
  } else {
    let sourceMoveRad = sourceMargin / radius;
    let targetMoveRad = targetMargin / radius;
    if (theta0 > 0) {
      sourceMoveRad *= -1;
      targetMoveRad *= -1;
    }
    position = positionsToLinePosition(moveOnCircumference(origin.source, center, sourceMoveRad), moveOnCircumference(origin.target, center, -targetMoveRad));
    let theta1 = calculateRelativeAngleRadian(fromVectors(center, origin.source), fromVectors(center, origin.target));
    let theta2 = calculateRelativeAngleRadian(fromPositions(center, { x: position.x1, y: position.y1 }), fromPositions(center, { x: position.x2, y: position.y2 }));
    if (theta0 * theta1 < 0) {
      theta1 = reverseAngleRadian(theta1);
      if (theta0 * theta2 < 0) {
        theta2 = reverseAngleRadian(theta2);
      }
    }
    if (theta1 * theta2 < 0) {
      const c = shiftedCenter.clone().add(shifted.v.normalize().multiplyScalar(0.5));
      position = positionsToLinePosition(shiftedCenter, c);
      return [position, curve];
    }
  }
  const [p1, p2] = toVectorsFromLinePosition(position);
  const control = calculateBezierCurveControlPoint(p1, center, p2, theta0).map((p) => p.toObject());
  curve = {
    center: shiftedCenter,
    theta: theta0,
    circle: { center, radius },
    control
  };
  return [position, curve];
}
const mouseEventHandlersKey = Symbol("mouseEventHandlers");
const MOVE_DETECTION_THRESHOLD = 3;
function _unwrapNodePosition(nodes, node) {
  var _a;
  const pos = (_a = nodes[node]) != null ? _a : { x: 0, y: 0 };
  return __spreadValues({}, pos);
}
function provideMouseOperation(container, nodePositions, zoomLevel, nodeStates, edgeStates, selectedNodes, selectedEdges, hoveredNodes, hoveredEdges, emitter) {
  onMounted(() => {
    var _a;
    (_a = container.value) == null ? void 0 : _a.addEventListener("pointerdown", handleContainerPointerDownEvent, {
      passive: true
    });
  });
  onUnmounted(() => {
    var _a;
    (_a = container.value) == null ? void 0 : _a.removeEventListener("pointerdown", handleContainerPointerDownEvent);
  });
  const state = {
    container: {
      moveCounter: 0,
      pointerCounter: 0
    },
    nodePointers: new Map(),
    follow: {
      followedPointerId: -1,
      nodeBasePositions: {}
    },
    hoveredNodes,
    hoveredNodesPre: new Set(),
    hoveredEdges,
    edgePointers: new Map(),
    edgePointerPeekCount: 0
  };
  const containerPointerHandlers = {
    pointermove: handleContainerPointerMoveEvent,
    pointerup: handleContainerPointerUpEvent,
    pointercancel: handleContainerPointerUpEvent
  };
  const nodePointerHandlers = {
    pointermove: handleNodePointerMoveEvent,
    pointerup: handleNodePointerUpEvent,
    pointercancel: handleNodePointerCancelEvent
  };
  const edgePointerHandlers = {
    pointerup: handleEdgePointerUpEvent,
    pointercancel: handleEdgePointerCancelEvent
  };
  function handleContainerPointerDownEvent(_) {
    state.container.moveCounter = 0;
    if (state.container.pointerCounter === 0) {
      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {
        var _a;
        (_a = container.value) == null ? void 0 : _a.addEventListener(ev, handler, { passive: true });
      });
    }
    state.container.pointerCounter++;
  }
  function handleContainerPointerMoveEvent(_) {
    state.container.moveCounter++;
  }
  function handleContainerPointerUpEvent(event) {
    state.container.pointerCounter--;
    if (state.container.pointerCounter === 0) {
      entriesOf(containerPointerHandlers).forEach(([ev, handler]) => {
        var _a;
        (_a = container.value) == null ? void 0 : _a.removeEventListener(ev, handler);
      });
      if (state.container.moveCounter <= MOVE_DETECTION_THRESHOLD) {
        if (event.shiftKey && (selectedNodes.size > 0 || selectedEdges.size > 0)) {
          return;
        }
        selectedNodes.clear();
        selectedEdges.clear();
      }
    }
  }
  function _updateFollowNodes(pointerState) {
    const isFollowed = state.follow.followedPointerId === pointerState.pointerId;
    const isSelectedNode = selectedNodes.has(pointerState.nodeId);
    const removed = !(pointerState.pointerId in state.nodePointers);
    if (isFollowed && removed || isFollowed && !isSelectedNode) {
      const candidate = MapUtil.valueOf(state.nodePointers).find((p) => selectedNodes.has(p.nodeId));
      if (!candidate) {
        state.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      pointerState = candidate;
      state.follow.followedPointerId = pointerState.pointerId;
    } else {
      const followed = state.nodePointers.get(state.follow.followedPointerId);
      if (!followed) {
        state.follow = { followedPointerId: -1, nodeBasePositions: {} };
        return;
      }
      pointerState = followed;
    }
    if (isFollowed || isSelectedNode) {
      const userGrabs = MapUtil.valueOf(state.nodePointers).map((n) => n.nodeId);
      state.follow.nodeBasePositions = Object.fromEntries(Array.from(selectedNodes).filter((n) => !userGrabs.includes(n)).filter((n) => {
        var _a;
        return (_a = nodeStates[n]) == null ? void 0 : _a.draggable;
      }).map((n) => [n, _unwrapNodePosition(nodePositions, n)]));
      pointerState.dragBasePosition = __spreadValues({}, pointerState.latestPosition);
      pointerState.nodeBasePosition = _unwrapNodePosition(nodePositions, pointerState.nodeId);
    }
  }
  watch(selectedNodes, () => {
    const pointerState = state.nodePointers.get(state.follow.followedPointerId);
    if (pointerState) {
      _updateFollowNodes(pointerState);
    }
  });
  function _calculateNodeNewPosition(pointerState, event) {
    const dx = pointerState.dragBasePosition.x - event.pageX;
    const dy = pointerState.dragBasePosition.y - event.pageY;
    const positions = state.follow.followedPointerId == pointerState.pointerId ? __spreadValues({
      [pointerState.nodeId]: pointerState.nodeBasePosition
    }, state.follow.nodeBasePositions) : { [pointerState.nodeId]: pointerState.nodeBasePosition };
    const z = zoomLevel.value;
    return Object.fromEntries(Object.entries(positions).map(([node, pos]) => [
      node,
      {
        x: pos.x - dx / z,
        y: pos.y - dy / z
      }
    ]));
  }
  function handleNodeClickEvent(node, event) {
    var _a, _b;
    if (event.shiftKey && selectedEdges.size > 0) {
      return;
    }
    selectedEdges.clear();
    const selectable = (_b = (_a = nodeStates[node]) == null ? void 0 : _a.selectable) != null ? _b : false;
    if (selectable) {
      const isTouchAnySelectedNode = MapUtil.valueOf(state.nodePointers).filter((p) => p.pointerId != event.pointerId && selectedNodes.has(p.nodeId)).length > 0;
      if (event.shiftKey || isTouchAnySelectedNode) {
        if (selectedNodes.has(node)) {
          selectedNodes.delete(node);
        } else if (!(typeof selectable === "number" && selectedNodes.size >= selectable)) {
          selectedNodes.add(node);
        }
      } else if (!selectedNodes.has(node)) {
        selectedNodes.clear();
        selectedNodes.add(node);
      }
    }
    emitter.emit("node:click", { node, event });
  }
  function handleNodePointerMoveEvent(event) {
    var _a;
    event.preventDefault();
    event.stopPropagation();
    const pointerState = state.nodePointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    pointerState.latestPosition = { x: event.pageX, y: event.pageY };
    pointerState.moveCounter++;
    if (pointerState.moveCounter <= MOVE_DETECTION_THRESHOLD) {
      return;
    }
    if (!((_a = nodeStates[pointerState.nodeId]) == null ? void 0 : _a.draggable)) {
      return;
    }
    if (pointerState.moveCounter === MOVE_DETECTION_THRESHOLD + 1) {
      const draggingNodes2 = _calculateNodeNewPosition(pointerState, {
        pointerId: pointerState.pointerId,
        pageX: pointerState.dragBasePosition.x,
        pageY: pointerState.dragBasePosition.y
      });
      emitter.emit("node:dragstart", draggingNodes2);
    }
    const draggingNodes = _calculateNodeNewPosition(pointerState, event);
    emitter.emit("node:pointermove", draggingNodes);
  }
  function handleNodePointerCancelEvent(event) {
    event.preventDefault();
    event.stopPropagation();
    let pointerState = state.nodePointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    for (pointerState of state.nodePointers.values()) {
      const node = pointerState.nodeId;
      const isMoved = pointerState.moveCounter > MOVE_DETECTION_THRESHOLD;
      if (isMoved) {
        const draggingNodes = _calculateNodeNewPosition(pointerState, {
          pointerId: pointerState.pointerId,
          pageX: pointerState.latestPosition.x,
          pageY: pointerState.latestPosition.y
        });
        emitter.emit("node:dragend", draggingNodes);
      }
      emitter.emit("node:pointerup", { node, event });
    }
    state.nodePointers.clear();
    state.follow = { followedPointerId: -1, nodeBasePositions: {} };
    entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {
      document.removeEventListener(ev, handler);
    });
    emitter.emit("view:mode", "default");
  }
  function handleNodePointerUpEvent(event) {
    var _a;
    event.preventDefault();
    event.stopPropagation();
    const pointerState = state.nodePointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    state.nodePointers.delete(event.pointerId);
    const node = pointerState.nodeId;
    const isMoved = pointerState.moveCounter > MOVE_DETECTION_THRESHOLD;
    if (isMoved) {
      if ((_a = nodeStates[pointerState.nodeId]) == null ? void 0 : _a.draggable) {
        const draggingNodes = _calculateNodeNewPosition(pointerState, event);
        emitter.emit("node:dragend", draggingNodes);
        emitter.emit("node:pointerup", { node, event });
      }
    } else {
      emitter.emit("node:pointerup", { node, event });
      handleNodeClickEvent(node, event);
    }
    if (state.nodePointers.size == 0) {
      state.follow = { followedPointerId: -1, nodeBasePositions: {} };
      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {
        document.removeEventListener(ev, handler);
      });
      emitter.emit("view:mode", "default");
    } else {
      _updateFollowNodes(pointerState);
    }
    state.hoveredNodes.clear();
    state.hoveredNodesPre.forEach(state.hoveredNodes.add, state.hoveredNodes);
  }
  function handleNodePointerDownEvent(node, event) {
    event.preventDefault();
    event.stopPropagation();
    if (state.edgePointers.size !== 0) {
      return;
    }
    if (state.nodePointers.size == 0) {
      emitter.emit("view:mode", "node");
      entriesOf(nodePointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler);
      });
    }
    const pointerState = {
      pointerId: event.pointerId,
      nodeId: node,
      moveCounter: 0,
      nodeBasePosition: _unwrapNodePosition(nodePositions, node),
      dragBasePosition: { x: event.pageX, y: event.pageY },
      latestPosition: { x: event.pageX, y: event.pageY }
    };
    state.nodePointers.set(event.pointerId, pointerState);
    if (selectedNodes.has(node)) {
      if (state.follow.followedPointerId < 0) {
        state.follow.followedPointerId = event.pointerId;
        _updateFollowNodes(pointerState);
      } else {
        delete state.follow.nodeBasePositions[pointerState.nodeId];
      }
    }
    emitter.emit("node:pointerdown", { node, event });
  }
  function handleNodePointerOverEvent(node, event) {
    state.hoveredNodesPre.add(node);
    if (state.nodePointers.size > 0) {
      return;
    }
    state.hoveredNodes.add(node);
    emitter.emit("node:pointerover", { node, event });
  }
  function handleNodePointerOutEvent(node, event) {
    state.hoveredNodesPre.delete(node);
    if (state.nodePointers.size > 0) {
      return;
    }
    state.hoveredNodes.delete(node);
    emitter.emit("node:pointerout", { node, event });
  }
  function handleEdgePointerDownEvent(edge, event) {
    event.preventDefault();
    event.stopPropagation();
    if (state.nodePointers.size !== 0) {
      return;
    }
    if (state.edgePointers.size == 0) {
      emitter.emit("view:mode", "edge");
      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
        document.addEventListener(ev, handler);
      });
      state.edgePointerPeekCount = 0;
    }
    state.edgePointerPeekCount++;
    const pointerState = {
      pointerId: event.pointerId,
      edgeId: edge
    };
    state.edgePointers.set(event.pointerId, pointerState);
    emitter.emit("edge:pointerdown", { edge, event });
  }
  function handleEdgePointerUpEvent(event) {
    event.preventDefault();
    event.stopPropagation();
    const pointerState = state.edgePointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    state.edgePointers.delete(event.pointerId);
    const edge = pointerState.edgeId;
    emitter.emit("edge:pointerup", { edge, event });
    if (state.edgePointers.size > 0 || state.edgePointerPeekCount === 1) {
      handleEdgeClickEvent(edge, event);
    }
    if (state.edgePointers.size === 0) {
      state.edgePointerPeekCount = 0;
      entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
        document.removeEventListener(ev, handler);
      });
      emitter.emit("view:mode", "default");
    }
  }
  function handleEdgePointerCancelEvent(event) {
    event.preventDefault();
    event.stopPropagation();
    const pointerState = state.edgePointers.get(event.pointerId);
    if (!pointerState) {
      return;
    }
    for (const pointerState2 of state.edgePointers.values()) {
      const edge = pointerState2.edgeId;
      emitter.emit("edge:pointerup", { edge, event });
    }
    state.edgePointers.clear();
    state.edgePointerPeekCount = 0;
    entriesOf(edgePointerHandlers).forEach(([ev, handler]) => {
      document.removeEventListener(ev, handler);
    });
    emitter.emit("view:mode", "default");
  }
  function handleEdgeClickEvent(edge, event) {
    var _a;
    if (event.shiftKey && selectedNodes.size > 0) {
      return;
    }
    selectedNodes.clear();
    const selectable = (_a = edgeStates[edge]) == null ? void 0 : _a.selectable;
    if (selectable) {
      const isTouchAnySelectedEdge = MapUtil.valueOf(state.edgePointers).filter((p) => p.pointerId != event.pointerId && selectedEdges.has(p.edgeId)).length > 0;
      if (event.shiftKey || isTouchAnySelectedEdge) {
        if (selectedEdges.has(edge)) {
          selectedEdges.delete(edge);
        } else if (!(typeof selectable === "number" && selectedEdges.size >= selectable)) {
          selectedEdges.add(edge);
        }
      } else {
        selectedEdges.clear();
        selectedEdges.add(edge);
      }
    }
    emitter.emit("edge:click", { edge, event });
  }
  function handleEdgePointerOverEvent(edge, event) {
    state.hoveredEdges.add(edge);
    emitter.emit("edge:pointerover", { edge, event });
  }
  function handleEdgePointerOutEvent(edge, event) {
    state.hoveredEdges.delete(edge);
    emitter.emit("edge:pointerout", { edge, event });
  }
  const provides = {
    selectedNodes,
    hoveredNodes,
    selectedEdges,
    hoveredEdges,
    handleNodePointerDownEvent,
    handleNodePointerOverEvent,
    handleNodePointerOutEvent,
    handleEdgePointerDownEvent,
    handleEdgePointerOverEvent,
    handleEdgePointerOutEvent
  };
  provide(mouseEventHandlersKey, provides);
  return provides;
}
function useMouseOperation() {
  return nonNull(inject(mouseEventHandlersKey), "mouseEventHandlers");
}
function mitt(n) {
  return { all: n = n || new Map(), on: function(t, e) {
    var i = n.get(t);
    i ? i.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i = n.get(t);
    i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i = n.get(t);
    i && i.slice().map(function(n2) {
      n2(e);
    }), (i = n.get("*")) && i.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
const eventEmitterKey = Symbol("emitter");
function provideEventEmitter() {
  const emitter = mitt();
  provide(eventEmitterKey, emitter);
  return emitter;
}
function useEventEmitter() {
  return {
    emitter: nonNull(inject(eventEmitterKey), "event emitter")
  };
}
var utilities = {
  getGlobalThis: function() {
    if (typeof globalThis !== "undefined")
      return globalThis;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof commonjsGlobal !== "undefined")
      return commonjsGlobal;
    if (typeof this !== "undefined")
      return this;
    throw new Error("Unable to locate global `this`");
  },
  extend: function(target, source) {
    target = target || {};
    for (var prop in source) {
      if (this.isObject(source[prop])) {
        target[prop] = this.extend(target[prop], source[prop]);
      } else {
        target[prop] = source[prop];
      }
    }
    return target;
  },
  isElement: function(o) {
    return o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || o && typeof o === "object" && o !== null && o.nodeType === 1 && typeof o.nodeName === "string";
  },
  isObject: function(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  },
  isNumber: function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  },
  getSvg: function(elementOrSelector) {
    var element, svg;
    if (!this.isElement(elementOrSelector)) {
      if (typeof elementOrSelector === "string" || elementOrSelector instanceof String) {
        element = document.querySelector(elementOrSelector);
        if (!element) {
          throw new Error("Provided selector did not find any elements. Selector: " + elementOrSelector);
        }
      } else {
        throw new Error("Provided selector is not an HTML object nor String");
      }
    } else {
      element = elementOrSelector;
    }
    if (element.tagName.toLowerCase() === "svg") {
      svg = element;
    } else {
      if (element.tagName.toLowerCase() === "object") {
        svg = element.contentDocument.documentElement;
      } else {
        if (element.tagName.toLowerCase() === "embed") {
          svg = element.getSVGDocument().documentElement;
        } else {
          if (element.tagName.toLowerCase() === "img") {
            throw new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.');
          } else {
            throw new Error("Cannot get SVG.");
          }
        }
      }
    }
    return svg;
  },
  proxy: function(fn, context) {
    return function() {
      return fn.apply(context, arguments);
    };
  },
  getType: function(o) {
    return Object.prototype.toString.apply(o).replace(/^\[object\s/, "").replace(/\]$/, "");
  },
  mouseAndTouchNormalize: function(evt, svg) {
    if (evt.clientX === void 0 || evt.clientX === null) {
      evt.clientX = 0;
      evt.clientY = 0;
      if (evt.touches !== void 0 && evt.touches.length) {
        if (evt.touches[0].clientX !== void 0) {
          evt.clientX = evt.touches[0].clientX;
          evt.clientY = evt.touches[0].clientY;
        } else if (evt.touches[0].pageX !== void 0) {
          var rect = svg.getBoundingClientRect();
          evt.clientX = evt.touches[0].pageX - rect.left;
          evt.clientY = evt.touches[0].pageY - rect.top;
        }
      } else if (evt.originalEvent !== void 0) {
        if (evt.originalEvent.clientX !== void 0) {
          evt.clientX = evt.originalEvent.clientX;
          evt.clientY = evt.originalEvent.clientY;
        }
      }
    }
  },
  touchNormalize: function(evt, svg, touch) {
    if (evt.touches !== void 0 && evt.touches.length) {
      if (evt.touches[touch].clientX !== void 0) {
        evt.clientX = evt.touches[touch].clientX;
        evt.clientY = evt.touches[touch].clientY;
      } else if (evt.touches[touch].pageX !== void 0) {
        var rect = svg.getBoundingClientRect();
        evt.clientX = evt.touches[touch].pageX - rect.left;
        evt.clientY = evt.touches[touch].pageY - rect.top;
      }
    } else {
      if (evt.clientX === void 0 || evt.clientX === null) {
        evt.clientX = 0;
        evt.clientY = 0;
        if (evt.originalEvent !== void 0) {
          if (evt.originalEvent.clientX !== void 0) {
            evt.clientX = evt.originalEvent.clientX;
            evt.clientY = evt.originalEvent.clientY;
          }
        }
      }
    }
  },
  isDblClick: function(evt, prevEvt) {
    if (evt.detail === 2) {
      return true;
    } else if (prevEvt !== void 0 && prevEvt !== null) {
      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp, touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2));
      return timeStampDiff < 250 && touchesDistance < 10;
    }
    return false;
  },
  now: Date.now || function() {
    return new Date().getTime();
  },
  throttle: function(func, wait, options) {
    var that = this;
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) {
      options = {};
    }
    var later = function() {
      previous = options.leading === false ? 0 : that.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) {
        context = args = null;
      }
    };
    return function() {
      var now = that.now();
      if (!previous && options.leading === false) {
        previous = now;
      }
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) {
          context = args = null;
        }
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  },
  createRequestAnimationFrame: function(refreshRate) {
    var timeout = null;
    if (refreshRate !== "auto" && refreshRate < 60 && refreshRate > 1) {
      timeout = Math.floor(1e3 / refreshRate);
    }
    if (timeout === null) {
      return window.requestAnimationFrame || requestTimeout(33);
    } else {
      return requestTimeout(timeout);
    }
  },
  calculateDistance: function(point1, point2) {
    var dx = point1.x - point2.x;
    var dy = point1.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
};
function requestTimeout(timeout) {
  return function(callback) {
    window.setTimeout(callback, timeout);
  };
}
var Utils$3 = utilities;
var uniwheel = function() {
  var prefix = "", _addEventListener, _removeEventListener, support, fns = [];
  var passiveTrueOption = { passive: true };
  var passiveFalseOption = { passive: false };
  if (Utils$3.getGlobalThis().addEventListener) {
    _addEventListener = "addEventListener";
    _removeEventListener = "removeEventListener";
  } else {
    _addEventListener = "attachEvent";
    _removeEventListener = "detachEvent";
    prefix = "on";
  }
  function getSupport() {
    if (!support) {
      support = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    }
    return support;
  }
  function createCallback(element, callback) {
    var fn = function(originalEvent) {
      !originalEvent && (originalEvent = window.event);
      var event = {
        originalEvent,
        target: originalEvent.target || originalEvent.srcElement,
        type: "wheel",
        deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          originalEvent.preventDefault ? originalEvent.preventDefault() : originalEvent.returnValue = false;
        }
      };
      if (getSupport() == "mousewheel") {
        event.deltaY = -1 / 40 * originalEvent.wheelDelta;
        originalEvent.wheelDeltaX && (event.deltaX = -1 / 40 * originalEvent.wheelDeltaX);
      } else {
        event.deltaY = originalEvent.detail;
      }
      return callback(event);
    };
    fns.push({
      element,
      fn
    });
    return fn;
  }
  function getCallback(element) {
    for (var i = 0; i < fns.length; i++) {
      if (fns[i].element === element) {
        return fns[i].fn;
      }
    }
    return function() {
    };
  }
  function removeCallback(element) {
    for (var i = 0; i < fns.length; i++) {
      if (fns[i].element === element) {
        return fns.splice(i, 1);
      }
    }
  }
  function _addWheelListener(elem, eventName, callback, isPassiveListener) {
    var cb;
    if (getSupport() === "wheel") {
      cb = callback;
    } else {
      cb = createCallback(elem, callback);
    }
    elem[_addEventListener](prefix + eventName, cb, isPassiveListener ? passiveTrueOption : passiveFalseOption);
  }
  function _removeWheelListener(elem, eventName, callback, isPassiveListener) {
    var cb;
    if (getSupport() === "wheel") {
      cb = callback;
    } else {
      cb = getCallback(elem);
    }
    elem[_removeEventListener](prefix + eventName, cb, isPassiveListener ? passiveTrueOption : passiveFalseOption);
    removeCallback(elem);
  }
  function addWheelListener(elem, callback, isPassiveListener) {
    _addWheelListener(elem, getSupport(), callback, isPassiveListener);
    if (getSupport() == "DOMMouseScroll") {
      _addWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
    }
  }
  function removeWheelListener(elem, callback, isPassiveListener) {
    _removeWheelListener(elem, getSupport(), callback, isPassiveListener);
    if (getSupport() == "DOMMouseScroll") {
      _removeWheelListener(elem, "MozMousePixelScroll", callback, isPassiveListener);
    }
  }
  return {
    on: addWheelListener,
    off: removeWheelListener
  };
}();
var Utils$2 = utilities, _browser = "unknown";
if (typeof document != "undefined" && !!document.documentMode) {
  _browser = "ie";
}
var svgUtilities = {
  svgNS: "http://www.w3.org/2000/svg",
  xmlNS: "http://www.w3.org/XML/1998/namespace",
  xmlnsNS: "http://www.w3.org/2000/xmlns/",
  xlinkNS: "http://www.w3.org/1999/xlink",
  evNS: "http://www.w3.org/2001/xml-events",
  getBoundingClientRectNormalized: function(svg) {
    if (svg.clientWidth && svg.clientHeight) {
      return { width: svg.clientWidth, height: svg.clientHeight };
    } else if (!!svg.getBoundingClientRect()) {
      return svg.getBoundingClientRect();
    } else {
      throw new Error("Cannot get BoundingClientRect for SVG.");
    }
  },
  getOrCreateViewport: function(svg, selector) {
    var viewport = null;
    if (Utils$2.isElement(selector)) {
      viewport = selector;
    } else {
      viewport = svg.querySelector(selector);
    }
    if (!viewport) {
      var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el) {
        return el.nodeName !== "defs" && el.nodeName !== "#text";
      });
      if (childNodes.length === 1 && childNodes[0].nodeName === "g" && childNodes[0].getAttribute("transform") === null) {
        viewport = childNodes[0];
      }
    }
    if (!viewport) {
      var viewportId = "viewport-" + new Date().toISOString().replace(/\D/g, "");
      viewport = document.createElementNS(this.svgNS, "g");
      viewport.setAttribute("id", viewportId);
      var svgChildren = svg.childNodes || svg.children;
      if (!!svgChildren && svgChildren.length > 0) {
        for (var i = svgChildren.length; i > 0; i--) {
          if (svgChildren[svgChildren.length - i].nodeName !== "defs") {
            viewport.appendChild(svgChildren[svgChildren.length - i]);
          }
        }
      }
      svg.appendChild(viewport);
    }
    var classNames = [];
    if (viewport.getAttribute("class")) {
      classNames = viewport.getAttribute("class").split(" ");
    }
    if (!~classNames.indexOf("svg-pan-zoom_viewport")) {
      classNames.push("svg-pan-zoom_viewport");
      viewport.setAttribute("class", classNames.join(" "));
    }
    return viewport;
  },
  setupSvgAttributes: function(svg) {
    svg.setAttribute("xmlns", this.svgNS);
    svg.setAttributeNS(this.xmlnsNS, "xmlns:xlink", this.xlinkNS);
    svg.setAttributeNS(this.xmlnsNS, "xmlns:ev", this.evNS);
    if (svg.parentNode !== null) {
      var style = svg.getAttribute("style") || "";
      if (style.toLowerCase().indexOf("overflow") === -1) {
        svg.setAttribute("style", "overflow: hidden; " + style);
      }
    }
  },
  internetExplorerRedisplayInterval: 300,
  refreshDefsGlobal: Utils$2.throttle(function() {
    var allDefs = document.querySelectorAll("defs");
    var allDefsCount = allDefs.length;
    for (var i = 0; i < allDefsCount; i++) {
      var thisDefs = allDefs[i];
      thisDefs.parentNode.insertBefore(thisDefs, thisDefs);
    }
  }, commonjsGlobal ? commonjsGlobal.internetExplorerRedisplayInterval : null),
  setCTM: function(element, matrix, defs) {
    var that = this, s = "matrix(" + matrix.a + "," + matrix.b + "," + matrix.c + "," + matrix.d + "," + matrix.e + "," + matrix.f + ")";
    element.setAttributeNS(null, "transform", s);
    if ("transform" in element.style) {
      element.style.transform = s;
    } else if ("-ms-transform" in element.style) {
      element.style["-ms-transform"] = s;
    } else if ("-webkit-transform" in element.style) {
      element.style["-webkit-transform"] = s;
    }
    if (_browser === "ie" && !!defs) {
      defs.parentNode.insertBefore(defs, defs);
      window.setTimeout(function() {
        that.refreshDefsGlobal();
      }, that.internetExplorerRedisplayInterval);
    }
  },
  getEventPoint: function(evt, svg) {
    var point = svg.createSVGPoint();
    Utils$2.mouseAndTouchNormalize(evt, svg);
    point.x = evt.clientX;
    point.y = evt.clientY;
    return point;
  },
  getTouchPoint: function(evt, svg, touch) {
    var point = svg.createSVGPoint();
    Utils$2.touchNormalize(evt, svg, touch);
    point.x = evt.clientX;
    point.y = evt.clientY;
    return point;
  },
  getSvgCenterPoint: function(svg, width, height) {
    return this.createSVGPoint(svg, width / 2, height / 2);
  },
  createSVGPoint: function(svg, x, y) {
    var point = svg.createSVGPoint();
    point.x = x;
    point.y = y;
    return point;
  }
};
var SvgUtils$2 = svgUtilities;
var controlIcons = {
  enable: function(instance) {
    var defs = instance.svg.querySelector("defs");
    if (!defs) {
      defs = document.createElementNS(SvgUtils$2.svgNS, "defs");
      instance.svg.appendChild(defs);
    }
    var styleEl = defs.querySelector("style#svg-pan-zoom-controls-styles");
    if (!styleEl) {
      var style = document.createElementNS(SvgUtils$2.svgNS, "style");
      style.setAttribute("id", "svg-pan-zoom-controls-styles");
      style.setAttribute("type", "text/css");
      style.textContent = ".svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }";
      defs.appendChild(style);
    }
    var zoomGroup = document.createElementNS(SvgUtils$2.svgNS, "g");
    zoomGroup.setAttribute("id", "svg-pan-zoom-controls");
    zoomGroup.setAttribute("transform", "translate(" + (instance.width - 70) + " " + (instance.height - 76) + ") scale(0.75)");
    zoomGroup.setAttribute("class", "svg-pan-zoom-control");
    zoomGroup.appendChild(this._createZoomIn(instance));
    zoomGroup.appendChild(this._createZoomReset(instance));
    zoomGroup.appendChild(this._createZoomOut(instance));
    instance.svg.appendChild(zoomGroup);
    instance.controlIcons = zoomGroup;
  },
  _createZoomIn: function(instance) {
    var zoomIn = document.createElementNS(SvgUtils$2.svgNS, "g");
    zoomIn.setAttribute("id", "svg-pan-zoom-zoom-in");
    zoomIn.setAttribute("transform", "translate(30.5 5) scale(0.015)");
    zoomIn.setAttribute("class", "svg-pan-zoom-control");
    zoomIn.addEventListener("click", function() {
      instance.getPublicInstance().zoomIn();
    }, false);
    zoomIn.addEventListener("touchstart", function() {
      instance.getPublicInstance().zoomIn();
    }, false);
    var zoomInBackground = document.createElementNS(SvgUtils$2.svgNS, "rect");
    zoomInBackground.setAttribute("x", "0");
    zoomInBackground.setAttribute("y", "0");
    zoomInBackground.setAttribute("width", "1500");
    zoomInBackground.setAttribute("height", "1400");
    zoomInBackground.setAttribute("class", "svg-pan-zoom-control-background");
    zoomIn.appendChild(zoomInBackground);
    var zoomInShape = document.createElementNS(SvgUtils$2.svgNS, "path");
    zoomInShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z");
    zoomInShape.setAttribute("class", "svg-pan-zoom-control-element");
    zoomIn.appendChild(zoomInShape);
    return zoomIn;
  },
  _createZoomReset: function(instance) {
    var resetPanZoomControl = document.createElementNS(SvgUtils$2.svgNS, "g");
    resetPanZoomControl.setAttribute("id", "svg-pan-zoom-reset-pan-zoom");
    resetPanZoomControl.setAttribute("transform", "translate(5 35) scale(0.4)");
    resetPanZoomControl.setAttribute("class", "svg-pan-zoom-control");
    resetPanZoomControl.addEventListener("click", function() {
      instance.getPublicInstance().reset();
    }, false);
    resetPanZoomControl.addEventListener("touchstart", function() {
      instance.getPublicInstance().reset();
    }, false);
    var resetPanZoomControlBackground = document.createElementNS(SvgUtils$2.svgNS, "rect");
    resetPanZoomControlBackground.setAttribute("x", "2");
    resetPanZoomControlBackground.setAttribute("y", "2");
    resetPanZoomControlBackground.setAttribute("width", "182");
    resetPanZoomControlBackground.setAttribute("height", "58");
    resetPanZoomControlBackground.setAttribute("class", "svg-pan-zoom-control-background");
    resetPanZoomControl.appendChild(resetPanZoomControlBackground);
    var resetPanZoomControlShape1 = document.createElementNS(SvgUtils$2.svgNS, "path");
    resetPanZoomControlShape1.setAttribute("d", "M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z");
    resetPanZoomControlShape1.setAttribute("class", "svg-pan-zoom-control-element");
    resetPanZoomControl.appendChild(resetPanZoomControlShape1);
    var resetPanZoomControlShape2 = document.createElementNS(SvgUtils$2.svgNS, "path");
    resetPanZoomControlShape2.setAttribute("d", "M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z");
    resetPanZoomControlShape2.setAttribute("class", "svg-pan-zoom-control-element");
    resetPanZoomControl.appendChild(resetPanZoomControlShape2);
    return resetPanZoomControl;
  },
  _createZoomOut: function(instance) {
    var zoomOut = document.createElementNS(SvgUtils$2.svgNS, "g");
    zoomOut.setAttribute("id", "svg-pan-zoom-zoom-out");
    zoomOut.setAttribute("transform", "translate(30.5 70) scale(0.015)");
    zoomOut.setAttribute("class", "svg-pan-zoom-control");
    zoomOut.addEventListener("click", function() {
      instance.getPublicInstance().zoomOut();
    }, false);
    zoomOut.addEventListener("touchstart", function() {
      instance.getPublicInstance().zoomOut();
    }, false);
    var zoomOutBackground = document.createElementNS(SvgUtils$2.svgNS, "rect");
    zoomOutBackground.setAttribute("x", "0");
    zoomOutBackground.setAttribute("y", "0");
    zoomOutBackground.setAttribute("width", "1500");
    zoomOutBackground.setAttribute("height", "1400");
    zoomOutBackground.setAttribute("class", "svg-pan-zoom-control-background");
    zoomOut.appendChild(zoomOutBackground);
    var zoomOutShape = document.createElementNS(SvgUtils$2.svgNS, "path");
    zoomOutShape.setAttribute("d", "M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z");
    zoomOutShape.setAttribute("class", "svg-pan-zoom-control-element");
    zoomOut.appendChild(zoomOutShape);
    return zoomOut;
  },
  disable: function(instance) {
    if (instance.controlIcons) {
      instance.controlIcons.parentNode.removeChild(instance.controlIcons);
      instance.controlIcons = null;
    }
  }
};
var SvgUtils$1 = svgUtilities, Utils$1 = utilities;
var ShadowViewport$1 = function(viewport, options) {
  this.init(viewport, options);
};
ShadowViewport$1.prototype.init = function(viewport, options) {
  this.viewport = viewport;
  this.options = options;
  this.originalState = { zoom: 1, x: 0, y: 0 };
  this.activeState = { zoom: 1, x: 0, y: 0 };
  this.updateCTMCached = Utils$1.proxy(this.updateCTM, this);
  this.requestAnimationFrame = Utils$1.createRequestAnimationFrame(this.options.refreshRate);
  this.viewBox = { x: 0, y: 0, width: 0, height: 0 };
  this.cacheViewBox();
  var newCTM = this.processCTM();
  this.setCTM(newCTM);
  this.updateCTM();
};
ShadowViewport$1.prototype.cacheViewBox = function() {
  var svgViewBox = this.options.svg.getAttribute("viewBox");
  if (svgViewBox) {
    var viewBoxValues = svgViewBox.split(/[\s\,]/).filter(function(v) {
      return v;
    }).map(parseFloat);
    this.viewBox.x = viewBoxValues[0];
    this.viewBox.y = viewBoxValues[1];
    this.viewBox.width = viewBoxValues[2];
    this.viewBox.height = viewBoxValues[3];
    var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
    this.activeState.zoom = zoom;
    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2;
    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2;
    this.updateCTMOnNextFrame();
    this.options.svg.removeAttribute("viewBox");
  } else {
    this.simpleViewBoxCache();
  }
};
ShadowViewport$1.prototype.simpleViewBoxCache = function() {
  var bBox = this.viewport.getBBox();
  this.viewBox.x = bBox.x;
  this.viewBox.y = bBox.y;
  this.viewBox.width = bBox.width;
  this.viewBox.height = bBox.height;
};
ShadowViewport$1.prototype.getViewBox = function() {
  return Utils$1.extend({}, this.viewBox);
};
ShadowViewport$1.prototype.processCTM = function() {
  var newCTM = this.getCTM();
  if (this.options.fit || this.options.contain) {
    var newScale;
    if (this.options.fit) {
      newScale = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
    } else {
      newScale = Math.max(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height);
    }
    newCTM.a = newScale;
    newCTM.d = newScale;
    newCTM.e = -this.viewBox.x * newScale;
    newCTM.f = -this.viewBox.y * newScale;
  }
  if (this.options.center) {
    var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x * 2) * newCTM.a) * 0.5, offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y * 2) * newCTM.a) * 0.5;
    newCTM.e = offsetX;
    newCTM.f = offsetY;
  }
  this.originalState.zoom = newCTM.a;
  this.originalState.x = newCTM.e;
  this.originalState.y = newCTM.f;
  return newCTM;
};
ShadowViewport$1.prototype.getOriginalState = function() {
  return Utils$1.extend({}, this.originalState);
};
ShadowViewport$1.prototype.getState = function() {
  return Utils$1.extend({}, this.activeState);
};
ShadowViewport$1.prototype.getZoom = function() {
  return this.activeState.zoom;
};
ShadowViewport$1.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom;
};
ShadowViewport$1.prototype.computeRelativeZoom = function(scale) {
  return scale / this.originalState.zoom;
};
ShadowViewport$1.prototype.getPan = function() {
  return { x: this.activeState.x, y: this.activeState.y };
};
ShadowViewport$1.prototype.getCTM = function() {
  var safeCTM = this.options.svg.createSVGMatrix();
  safeCTM.a = this.activeState.zoom;
  safeCTM.b = 0;
  safeCTM.c = 0;
  safeCTM.d = this.activeState.zoom;
  safeCTM.e = this.activeState.x;
  safeCTM.f = this.activeState.y;
  return safeCTM;
};
ShadowViewport$1.prototype.setCTM = function(newCTM) {
  var willZoom = this.isZoomDifferent(newCTM), willPan = this.isPanDifferent(newCTM);
  if (willZoom || willPan) {
    if (willZoom) {
      if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {
        newCTM.a = newCTM.d = this.activeState.zoom;
        willZoom = false;
      } else {
        this.updateCache(newCTM);
        this.options.onZoom(this.getRelativeZoom());
      }
    }
    if (willPan) {
      var preventPan = this.options.beforePan(this.getPan(), {
        x: newCTM.e,
        y: newCTM.f
      }), preventPanX = false, preventPanY = false;
      if (preventPan === false) {
        newCTM.e = this.getPan().x;
        newCTM.f = this.getPan().y;
        preventPanX = preventPanY = true;
      } else if (Utils$1.isObject(preventPan)) {
        if (preventPan.x === false) {
          newCTM.e = this.getPan().x;
          preventPanX = true;
        } else if (Utils$1.isNumber(preventPan.x)) {
          newCTM.e = preventPan.x;
        }
        if (preventPan.y === false) {
          newCTM.f = this.getPan().y;
          preventPanY = true;
        } else if (Utils$1.isNumber(preventPan.y)) {
          newCTM.f = preventPan.y;
        }
      }
      if (preventPanX && preventPanY || !this.isPanDifferent(newCTM)) {
        willPan = false;
      } else {
        this.updateCache(newCTM);
        this.options.onPan(this.getPan());
      }
    }
    if (willZoom || willPan) {
      this.updateCTMOnNextFrame();
    }
  }
};
ShadowViewport$1.prototype.isZoomDifferent = function(newCTM) {
  return this.activeState.zoom !== newCTM.a;
};
ShadowViewport$1.prototype.isPanDifferent = function(newCTM) {
  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f;
};
ShadowViewport$1.prototype.updateCache = function(newCTM) {
  this.activeState.zoom = newCTM.a;
  this.activeState.x = newCTM.e;
  this.activeState.y = newCTM.f;
};
ShadowViewport$1.prototype.pendingUpdate = false;
ShadowViewport$1.prototype.updateCTMOnNextFrame = function() {
  if (!this.pendingUpdate) {
    this.pendingUpdate = true;
    this.requestAnimationFrame.call(window, this.updateCTMCached);
  }
};
ShadowViewport$1.prototype.updateCTM = function() {
  var ctm = this.getCTM();
  SvgUtils$1.setCTM(this.viewport, ctm, this.defs);
  this.pendingUpdate = false;
  if (this.options.onUpdatedCTM) {
    this.options.onUpdatedCTM(ctm);
  }
};
var shadowViewport = function(viewport, options) {
  return new ShadowViewport$1(viewport, options);
};
var Wheel = uniwheel, ControlIcons = controlIcons, Utils = utilities, SvgUtils = svgUtilities, ShadowViewport = shadowViewport;
var SvgPanZoom = function(svg, options) {
  this.init(svg, options);
};
var optionsDefaults = {
  viewportSelector: ".svg-pan-zoom_viewport",
  panEnabled: true,
  controlIconsEnabled: false,
  zoomEnabled: true,
  dblClickZoomEnabled: true,
  mouseWheelZoomEnabled: true,
  preventMouseEventsDefault: true,
  zoomScaleSensitivity: 0.1,
  minZoom: 0.5,
  maxZoom: 10,
  fit: true,
  contain: false,
  center: true,
  refreshRate: "auto",
  beforeZoom: null,
  onZoom: null,
  beforePan: null,
  onPan: null,
  customEventsHandler: null,
  eventsListenerElement: null,
  onUpdatedCTM: null
};
var passiveListenerTrueOption = { passive: true };
var passiveListenerFalseOption = { passive: false };
SvgPanZoom.prototype.init = function(svg, options) {
  var that = this;
  this.svg = svg;
  this.defs = svg.querySelector("defs");
  SvgUtils.setupSvgAttributes(this.svg);
  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options);
  this.state = "none";
  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg);
  this.width = boundingClientRectNormalized.width;
  this.height = boundingClientRectNormalized.height;
  this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {
    svg: this.svg,
    width: this.width,
    height: this.height,
    fit: this.options.fit,
    contain: this.options.contain,
    center: this.options.center,
    refreshRate: this.options.refreshRate,
    beforeZoom: function(oldScale, newScale) {
      if (that.viewport && that.options.beforeZoom) {
        return that.options.beforeZoom(oldScale, newScale);
      }
    },
    onZoom: function(scale) {
      if (that.viewport && that.options.onZoom) {
        return that.options.onZoom(scale);
      }
    },
    beforePan: function(oldPoint, newPoint) {
      if (that.viewport && that.options.beforePan) {
        return that.options.beforePan(oldPoint, newPoint);
      }
    },
    onPan: function(point) {
      if (that.viewport && that.options.onPan) {
        return that.options.onPan(point);
      }
    },
    onUpdatedCTM: function(ctm) {
      if (that.viewport && that.options.onUpdatedCTM) {
        return that.options.onUpdatedCTM(ctm);
      }
    }
  });
  var publicInstance = this.getPublicInstance();
  publicInstance.setBeforeZoom(this.options.beforeZoom);
  publicInstance.setOnZoom(this.options.onZoom);
  publicInstance.setBeforePan(this.options.beforePan);
  publicInstance.setOnPan(this.options.onPan);
  publicInstance.setOnUpdatedCTM(this.options.onUpdatedCTM);
  if (this.options.controlIconsEnabled) {
    ControlIcons.enable(this);
  }
  this.lastMouseWheelEventTime = Date.now();
  this.setupHandlers();
};
SvgPanZoom.prototype.setupHandlers = function() {
  var that = this, prevEvt = null;
  this.eventListeners = {
    mousedown: function(evt) {
      var result = that.handleMouseDown(evt, prevEvt);
      prevEvt = evt;
      return result;
    },
    touchstart: function(evt) {
      var result = that.handleTouchStart(evt, prevEvt);
      prevEvt = evt;
      return result;
    },
    mouseup: function(evt) {
      return that.handleMouseUp(evt);
    },
    touchend: function(evt) {
      return that.handleTouchEnd(evt);
    },
    mousemove: function(evt) {
      return that.handleMouseMove(evt);
    },
    touchmove: function(evt) {
      return that.handleTouchMove(evt);
    },
    mouseleave: function(evt) {
      return that.handleMouseUp(evt);
    },
    touchleave: function(evt) {
      return that.handleTouchEnd(evt);
    },
    touchcancel: function(evt) {
      return that.handleTouchEnd(evt);
    }
  };
  if (this.options.customEventsHandler != null) {
    this.options.customEventsHandler.init({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
    var haltEventListeners = this.options.customEventsHandler.haltEventListeners;
    if (haltEventListeners && haltEventListeners.length) {
      for (var i = haltEventListeners.length - 1; i >= 0; i--) {
        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {
          delete this.eventListeners[haltEventListeners[i]];
        }
      }
    }
  }
  for (var event in this.eventListeners) {
    (this.options.eventsListenerElement || this.svg).addEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerTrueOption : passiveListenerFalseOption);
  }
  if (this.options.mouseWheelZoomEnabled) {
    this.options.mouseWheelZoomEnabled = false;
    this.enableMouseWheelZoom();
  }
};
SvgPanZoom.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var that = this;
    this.wheelListener = function(evt) {
      return that.handleMouseWheel(evt);
    };
    var isPassiveListener = !this.options.preventMouseEventsDefault;
    Wheel.on(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
    this.options.mouseWheelZoomEnabled = true;
  }
};
SvgPanZoom.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    var isPassiveListener = !this.options.preventMouseEventsDefault;
    Wheel.off(this.options.eventsListenerElement || this.svg, this.wheelListener, isPassiveListener);
    this.options.mouseWheelZoomEnabled = false;
  }
};
SvgPanZoom.prototype.handleMouseWheel = function(evt) {
  if (!this.options.zoomEnabled || this.state !== "none") {
    return;
  }
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  var delta = evt.deltaY || 1, timeDelta = Date.now() - this.lastMouseWheelEventTime, divider = 3 + Math.max(0, 30 - timeDelta);
  this.lastMouseWheelEventTime = Date.now();
  if ("deltaMode" in evt && evt.deltaMode === 0 && evt.wheelDelta) {
    delta = evt.deltaY === 0 ? 0 : Math.abs(evt.wheelDelta) / evt.deltaY;
  }
  delta = -0.3 < delta && delta < 0.3 ? delta : (delta > 0 ? 1 : -1) * Math.log(Math.abs(delta) + 10) / divider;
  var inversedScreenCTM = this.svg.getScreenCTM().inverse(), relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM), zoom = Math.pow(1 + this.options.zoomScaleSensitivity, -1 * delta);
  this.zoomAtPoint(zoom, relativeMousePoint);
};
SvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {
  var originalState = this.viewport.getOriginalState();
  if (!zoomAbsolute) {
    if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {
      zoomScale = this.options.minZoom * originalState.zoom / this.getZoom();
    } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {
      zoomScale = this.options.maxZoom * originalState.zoom / this.getZoom();
    }
  } else {
    zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale));
    zoomScale = zoomScale / this.getZoom();
  }
  var oldCTM = this.viewport.getCTM(), relativePoint = point.matrixTransform(oldCTM.inverse()), modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y), newCTM = oldCTM.multiply(modifier);
  if (newCTM.a !== oldCTM.a) {
    this.viewport.setCTM(newCTM);
  }
};
SvgPanZoom.prototype.zoom = function(scale, absolute) {
  this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute);
};
SvgPanZoom.prototype.publicZoom = function(scale, absolute) {
  if (absolute) {
    scale = this.computeFromRelativeZoom(scale);
  }
  this.zoom(scale, absolute);
};
SvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {
  if (absolute) {
    scale = this.computeFromRelativeZoom(scale);
  }
  if (Utils.getType(point) !== "SVGPoint") {
    if ("x" in point && "y" in point) {
      point = SvgUtils.createSVGPoint(this.svg, point.x, point.y);
    } else {
      throw new Error("Given point is invalid");
    }
  }
  this.zoomAtPoint(scale, point, absolute);
};
SvgPanZoom.prototype.getZoom = function() {
  return this.viewport.getZoom();
};
SvgPanZoom.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom();
};
SvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {
  return zoom * this.viewport.getOriginalState().zoom;
};
SvgPanZoom.prototype.resetZoom = function() {
  var originalState = this.viewport.getOriginalState();
  this.zoom(originalState.zoom, true);
};
SvgPanZoom.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
};
SvgPanZoom.prototype.reset = function() {
  this.resetZoom();
  this.resetPan();
};
SvgPanZoom.prototype.handleDblClick = function(evt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  if (this.options.controlIconsEnabled) {
    var targetClass = evt.target.getAttribute("class") || "";
    if (targetClass.indexOf("svg-pan-zoom-control") > -1) {
      return false;
    }
  }
  var zoomFactor;
  if (evt.shiftKey) {
    zoomFactor = 1 / ((1 + this.options.zoomScaleSensitivity) * 2);
  } else {
    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2;
  }
  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse());
  this.zoomAtPoint(zoomFactor, point);
};
SvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  Utils.mouseAndTouchNormalize(evt, this.svg);
  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)) {
    this.handleDblClick(evt);
  } else {
    this.state = "pan";
    this.firstEventCTM = this.viewport.getCTM();
    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
  }
};
SvgPanZoom.prototype.handleMouseMove = function(evt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  if (this.state === "pan" && this.options.panEnabled) {
    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse()), viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
    this.viewport.setCTM(viewportCTM);
  }
};
SvgPanZoom.prototype.handleMouseUp = function(evt) {
  if (this.options.preventMouseEventsDefault) {
    if (evt.preventDefault) {
      evt.preventDefault();
    } else {
      evt.returnValue = false;
    }
  }
  if (this.state === "pan") {
    this.state = "none";
  }
};
SvgPanZoom.prototype.handleTouchStart = function(evt, prevEvt) {
  if (evt.touches.length == 1) {
    this.handleMouseDown(evt, prevEvt);
  } else {
    if (this.options.preventMouseEventsDefault) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    }
    this.firstEventCTM = this.viewport.getCTM();
    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);
    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);
    this.firstDistance = Utils.calculateDistance(touch1, touch2);
    touch1.x = (touch1.x + touch2.x) / 2;
    touch1.y = (touch1.y + touch2.y) / 2;
    this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());
    this.firstZoomLevel = this.getZoom();
  }
};
SvgPanZoom.prototype.handleTouchMove = function(evt) {
  if (evt.touches.length == 1) {
    this.handleMouseMove(evt);
  } else {
    if (this.options.preventMouseEventsDefault) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    }
    if (!this.options.panEnabled && !this.options.zoomEnabled) {
      return;
    }
    var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);
    var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);
    var center = this.svg.createSVGPoint();
    center.x = (touch1.x + touch2.x) / 2;
    center.y = (touch1.y + touch2.y) / 2;
    if (this.state === "pan" && this.options.panEnabled) {
      var point = center.matrixTransform(this.firstEventCTM.inverse());
      var viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y);
      this.viewport.setCTM(viewportCTM);
    }
    if (this.options.zoomEnabled) {
      var distance = Utils.calculateDistance(touch1, touch2);
      var scale = distance / this.firstDistance;
      var inversedScreenCTM = this.svg.getScreenCTM().inverse();
      var relativeTouchPoint = center.matrixTransform(inversedScreenCTM);
      this.zoomAtPoint(this.firstZoomLevel * scale, relativeTouchPoint, true);
    }
  }
};
SvgPanZoom.prototype.handleTouchEnd = function(evt) {
  if (evt.touches.length == 0) {
    this.handleMouseUp(evt);
  } else {
    if (this.options.preventMouseEventsDefault) {
      if (evt.preventDefault) {
        evt.preventDefault();
      } else {
        evt.returnValue = false;
      }
    }
    this.firstEventCTM = this.viewport.getCTM();
    if (evt.touches.length == 1) {
      this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse());
    } else {
      var touch1 = SvgUtils.getTouchPoint(evt, this.svg, 0);
      var touch2 = SvgUtils.getTouchPoint(evt, this.svg, 1);
      this.firstDistance = Utils.calculateDistance(touch1, touch2);
      touch1.x = (touch1.x + touch2.x) / 2;
      touch1.y = (touch1.y + touch2.y) / 2;
      this.stateOrigin = touch1.matrixTransform(this.firstEventCTM.inverse());
    }
  }
};
SvgPanZoom.prototype.fit = function() {
  var viewBox = this.viewport.getViewBox(), newScale = Math.min(this.width / viewBox.width, this.height / viewBox.height);
  this.zoom(newScale, true);
};
SvgPanZoom.prototype.contain = function() {
  var viewBox = this.viewport.getViewBox(), newScale = Math.max(this.width / viewBox.width, this.height / viewBox.height);
  this.zoom(newScale, true);
};
SvgPanZoom.prototype.center = function() {
  var viewBox = this.viewport.getViewBox(), offsetX = (this.width - (viewBox.width + viewBox.x * 2) * this.getZoom()) * 0.5, offsetY = (this.height - (viewBox.height + viewBox.y * 2) * this.getZoom()) * 0.5;
  this.getPublicInstance().pan({ x: offsetX, y: offsetY });
};
SvgPanZoom.prototype.updateBBox = function() {
  this.viewport.simpleViewBoxCache();
};
SvgPanZoom.prototype.pan = function(point) {
  var viewportCTM = this.viewport.getCTM();
  viewportCTM.e = point.x;
  viewportCTM.f = point.y;
  this.viewport.setCTM(viewportCTM);
};
SvgPanZoom.prototype.panBy = function(point) {
  var viewportCTM = this.viewport.getCTM();
  viewportCTM.e += point.x;
  viewportCTM.f += point.y;
  this.viewport.setCTM(viewportCTM);
};
SvgPanZoom.prototype.getPan = function() {
  var state = this.viewport.getState();
  return { x: state.x, y: state.y };
};
SvgPanZoom.prototype.resize = function() {
  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg);
  this.width = boundingClientRectNormalized.width;
  this.height = boundingClientRectNormalized.height;
  var viewport = this.viewport;
  viewport.options.width = this.width;
  viewport.options.height = this.height;
  viewport.processCTM();
  if (this.options.controlIconsEnabled) {
    this.getPublicInstance().disableControlIcons();
    this.getPublicInstance().enableControlIcons();
  }
};
SvgPanZoom.prototype.destroy = function() {
  var that = this;
  this.beforeZoom = null;
  this.onZoom = null;
  this.beforePan = null;
  this.onPan = null;
  this.onUpdatedCTM = null;
  if (this.options.customEventsHandler != null) {
    this.options.customEventsHandler.destroy({
      svgElement: this.svg,
      eventsListenerElement: this.options.eventsListenerElement,
      instance: this.getPublicInstance()
    });
  }
  for (var event in this.eventListeners) {
    (this.options.eventsListenerElement || this.svg).removeEventListener(event, this.eventListeners[event], !this.options.preventMouseEventsDefault ? passiveListenerTrueOption : passiveListenerFalseOption);
  }
  this.disableMouseWheelZoom();
  this.getPublicInstance().disableControlIcons();
  this.reset();
  instancesStore = instancesStore.filter(function(instance) {
    return instance.svg !== that.svg;
  });
  delete this.options;
  delete this.viewport;
  delete this.publicInstance;
  delete this.pi;
  this.getPublicInstance = function() {
    return null;
  };
};
SvgPanZoom.prototype.getPublicInstance = function() {
  var that = this;
  if (!this.publicInstance) {
    this.publicInstance = this.pi = {
      enablePan: function() {
        that.options.panEnabled = true;
        return that.pi;
      },
      disablePan: function() {
        that.options.panEnabled = false;
        return that.pi;
      },
      isPanEnabled: function() {
        return !!that.options.panEnabled;
      },
      pan: function(point) {
        that.pan(point);
        return that.pi;
      },
      panBy: function(point) {
        that.panBy(point);
        return that.pi;
      },
      getPan: function() {
        return that.getPan();
      },
      setBeforePan: function(fn) {
        that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      setOnPan: function(fn) {
        that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      enableZoom: function() {
        that.options.zoomEnabled = true;
        return that.pi;
      },
      disableZoom: function() {
        that.options.zoomEnabled = false;
        return that.pi;
      },
      isZoomEnabled: function() {
        return !!that.options.zoomEnabled;
      },
      enableControlIcons: function() {
        if (!that.options.controlIconsEnabled) {
          that.options.controlIconsEnabled = true;
          ControlIcons.enable(that);
        }
        return that.pi;
      },
      disableControlIcons: function() {
        if (that.options.controlIconsEnabled) {
          that.options.controlIconsEnabled = false;
          ControlIcons.disable(that);
        }
        return that.pi;
      },
      isControlIconsEnabled: function() {
        return !!that.options.controlIconsEnabled;
      },
      enableDblClickZoom: function() {
        that.options.dblClickZoomEnabled = true;
        return that.pi;
      },
      disableDblClickZoom: function() {
        that.options.dblClickZoomEnabled = false;
        return that.pi;
      },
      isDblClickZoomEnabled: function() {
        return !!that.options.dblClickZoomEnabled;
      },
      enableMouseWheelZoom: function() {
        that.enableMouseWheelZoom();
        return that.pi;
      },
      disableMouseWheelZoom: function() {
        that.disableMouseWheelZoom();
        return that.pi;
      },
      isMouseWheelZoomEnabled: function() {
        return !!that.options.mouseWheelZoomEnabled;
      },
      setZoomScaleSensitivity: function(scale) {
        that.options.zoomScaleSensitivity = scale;
        return that.pi;
      },
      setMinZoom: function(zoom) {
        that.options.minZoom = zoom;
        return that.pi;
      },
      setMaxZoom: function(zoom) {
        that.options.maxZoom = zoom;
        return that.pi;
      },
      setBeforeZoom: function(fn) {
        that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      setOnZoom: function(fn) {
        that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      zoom: function(scale) {
        that.publicZoom(scale, true);
        return that.pi;
      },
      zoomBy: function(scale) {
        that.publicZoom(scale, false);
        return that.pi;
      },
      zoomAtPoint: function(scale, point) {
        that.publicZoomAtPoint(scale, point, true);
        return that.pi;
      },
      zoomAtPointBy: function(scale, point) {
        that.publicZoomAtPoint(scale, point, false);
        return that.pi;
      },
      zoomIn: function() {
        this.zoomBy(1 + that.options.zoomScaleSensitivity);
        return that.pi;
      },
      zoomOut: function() {
        this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity));
        return that.pi;
      },
      getZoom: function() {
        return that.getRelativeZoom();
      },
      setOnUpdatedCTM: function(fn) {
        that.options.onUpdatedCTM = fn === null ? null : Utils.proxy(fn, that.publicInstance);
        return that.pi;
      },
      resetZoom: function() {
        that.resetZoom();
        return that.pi;
      },
      resetPan: function() {
        that.resetPan();
        return that.pi;
      },
      reset: function() {
        that.reset();
        return that.pi;
      },
      fit: function() {
        that.fit();
        return that.pi;
      },
      contain: function() {
        that.contain();
        return that.pi;
      },
      center: function() {
        that.center();
        return that.pi;
      },
      updateBBox: function() {
        that.updateBBox();
        return that.pi;
      },
      resize: function() {
        that.resize();
        return that.pi;
      },
      getSizes: function() {
        return {
          width: that.width,
          height: that.height,
          realZoom: that.getZoom(),
          viewBox: that.viewport.getViewBox()
        };
      },
      destroy: function() {
        that.destroy();
        return that.pi;
      }
    };
  }
  return this.publicInstance;
};
var instancesStore = [];
var svgPanZoom = function(elementOrSelector, options) {
  var svg = Utils.getSvg(elementOrSelector);
  if (svg === null) {
    return null;
  } else {
    for (var i = instancesStore.length - 1; i >= 0; i--) {
      if (instancesStore[i].svg === svg) {
        return instancesStore[i].instance.getPublicInstance();
      }
    }
    instancesStore.push({
      svg,
      instance: new SvgPanZoom(svg, options)
    });
    return instancesStore[instancesStore.length - 1].instance.getPublicInstance();
  }
};
var svgPanZoom_1 = svgPanZoom;
const methods = {
  fitToContents() {
    this.fit().center().zoomOut().zoomOut();
    return this;
  },
  getViewArea() {
    const sizes = this.getSizes();
    const pan = this.getPan();
    const scale = sizes.realZoom;
    pan.x /= scale;
    pan.y /= scale;
    const viewport = {
      width: sizes.width / scale,
      height: sizes.height / scale
    };
    return {
      box: {
        top: -pan.y,
        bottom: viewport.height - pan.y,
        left: -pan.x,
        right: viewport.width - pan.x
      },
      center: {
        x: viewport.width / 2 - pan.x,
        y: viewport.height / 2 - pan.y
      }
    };
  },
  getRealZoom() {
    return this.getSizes().realZoom;
  },
  applyAbsoluteZoomLevel(zoomLevel, minZoomLevel, maxZoomLevel) {
    const min = Math.min(1e-4, minZoomLevel);
    const max = Math.max(min, maxZoomLevel);
    const zoom = Math.max(Math.min(max, zoomLevel), min);
    const realZoom = this.getRealZoom();
    const relativeZoom = this.getZoom();
    const originalZoom = realZoom / relativeZoom;
    this.setMinZoom(min / originalZoom).setMaxZoom(max / originalZoom).zoom(zoom / originalZoom);
  },
  isPanEnabled() {
    return this._isPanEnabled;
  },
  enablePan() {
    this._isPanEnabled = true;
    this._internalEnablePan();
    return this;
  },
  disablePan() {
    this._isPanEnabled = false;
    this._internalDisablePan();
    return this;
  },
  isZoomEnabled() {
    return this._isZoomEnabled;
  },
  enableZoom() {
    this._isZoomEnabled = true;
    this._internalEnableZoom();
    return this;
  },
  disableZoom() {
    this._isZoomEnabled = false;
    this._internalDisableZoom();
    return this;
  },
  setPanEnabled(enabled) {
    if (enabled) {
      this.enablePan();
    } else {
      this.disablePan();
    }
    return this;
  },
  setZoomEnabled(enabled) {
    if (enabled) {
      this.enableZoom();
      this.enableDblClickZoom();
    } else {
      this.disableZoom();
      this.disableDblClickZoom();
    }
    return this;
  }
};
function constructor(svgPanZoom2, options) {
  var _a, _b;
  const instance = svgPanZoom2;
  instance._isPanEnabled = (_a = options.panEnabled) != null ? _a : true;
  instance._isZoomEnabled = (_b = options == null ? void 0 : options.zoomEnabled) != null ? _b : true;
  instance._internalIsPanEnabled = instance.isPanEnabled;
  instance._internalEnablePan = instance.enablePan;
  instance._internalDisablePan = instance.disablePan;
  instance._internalIsZoomEnabled = instance.isZoomEnabled;
  instance._internalEnableZoom = instance.enableZoom;
  instance._internalDisableZoom = instance.disableZoom;
  Object.assign(svgPanZoom2, methods);
  return instance;
}
function createSvgPanZoomEx(svg, options) {
  var _a, _b, _c, _d, _e, _f;
  const userInit = (_b = (_a = options.customEventsHandler) == null ? void 0 : _a.init) != null ? _b : (_) => {
  };
  const userDestroy = (_d = (_c = options.customEventsHandler) == null ? void 0 : _c.destroy) != null ? _d : (_) => {
  };
  const haltEventListeners = (_f = (_e = options.customEventsHandler) == null ? void 0 : _e.haltEventListeners) != null ? _f : [];
  if (options.mouseWheelZoomEnabled === void 0) {
    options.mouseWheelZoomEnabled = options.zoomEnabled;
  }
  options.customEventsHandler = {
    init: (o) => {
      constructor(o.instance, options);
      userInit(o);
    },
    destroy: (o) => userDestroy(o),
    haltEventListeners
  };
  return svgPanZoom_1(svg, options);
}
var State;
(function(State2) {
  State2[State2["INITIAL"] = 0] = "INITIAL";
  State2[State2["MOUNTED"] = 1] = "MOUNTED";
  State2[State2["UNMOUNTED"] = 2] = "UNMOUNTED";
})(State || (State = {}));
function useSvgPanZoom(svg, options) {
  const instance = ref();
  let state = 0;
  const mountedCallbacks = [];
  const unmountedCallbacks = [];
  const instanceMounted = () => {
    state = 1;
    mountedCallbacks.forEach((c) => c());
    mountedCallbacks.length = 0;
  };
  const instanceUnmounted = () => {
    state = 2;
    unmountedCallbacks.forEach((c) => c());
    unmountedCallbacks.length = 0;
  };
  onMounted(() => {
    var _a, _b, _c, _d, _e, _f;
    const element = nonNull(svg.value, "<svg>");
    const userInit = (_b = (_a = options.customEventsHandler) == null ? void 0 : _a.init) != null ? _b : (_) => {
    };
    const userDestroy = (_d = (_c = options.customEventsHandler) == null ? void 0 : _c.destroy) != null ? _d : (_) => {
    };
    const haltEventListeners = (_f = (_e = options.customEventsHandler) == null ? void 0 : _e.haltEventListeners) != null ? _f : [];
    options.customEventsHandler = {
      init: (o) => {
        instance.value = o.instance;
        userInit(o);
        instanceMounted();
      },
      destroy: (o) => {
        instanceUnmounted();
        userDestroy(o);
      },
      haltEventListeners
    };
    createSvgPanZoomEx(element, options);
  });
  onUnmounted(() => {
    var _a;
    (_a = instance.value) == null ? void 0 : _a.destroy();
  });
  const onSvgPanZoomMounted = (callback) => {
    if (state === 0) {
      mountedCallbacks.push(callback);
    } else if (state === 1) {
      callback();
    }
  };
  const onSvgPanZoomUnmounted = (callback) => {
    if (state === 0 || state === 1) {
      unmountedCallbacks.push(callback);
    } else {
      callback();
    }
  };
  return { svgPanZoom: instance, onSvgPanZoomMounted, onSvgPanZoomUnmounted };
}
const zoomLevelKey = Symbol("zoomLevel");
function provideZoomLevel(zoomLevel, viewStyle) {
  const scale = computed(() => {
    return viewStyle.scalingObjects ? 1 : 1 / zoomLevel.value;
  });
  provide(zoomLevelKey, {
    zoomLevel,
    scale
  });
  return { scale };
}
function useZoomLevel() {
  return nonNull(inject(zoomLevelKey), "zoomLevel");
}
const LayerPositions = [
  "paths",
  "nodes",
  "focusring",
  "edges",
  "base",
  "grid",
  "background",
  "root"
];
const _hoisted_1$d = ["cx", "cy", "r", "fill", "stroke", "stroke-width", "stroke-dasharray"];
const _hoisted_2$3 = ["x", "y", "width", "height", "rx", "ry", "fill", "stroke", "stroke-width", "stroke-dasharray"];
const _sfc_main$l = /* @__PURE__ */ defineComponent({
  props: {
    baseX: {
      type: Number,
      default: 0
    },
    baseY: {
      type: Number,
      default: 0
    },
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const x = ref(props.baseX);
    const y = ref(props.baseY);
    const strokeWidth = ref(0);
    const strokeColor = ref("#000000");
    const strokeDasharray = ref(void 0);
    const radius = ref(0);
    const width = ref(0);
    const height = ref(0);
    const borderRadius = ref(0);
    watchEffect(() => {
      var _a;
      const s = scale.value;
      strokeWidth.value = props.config.strokeWidth * s;
      strokeColor.value = (_a = props.config.strokeColor) != null ? _a : "none";
      strokeDasharray.value = applyScaleToDasharray(props.config.strokeDasharray, s);
      if (props.config.type === "circle") {
        x.value = props.baseX;
        y.value = props.baseY;
        radius.value = props.config.radius * s;
      } else {
        width.value = props.config.width * s;
        height.value = props.config.height * s;
        borderRadius.value = props.config.borderRadius * s;
        x.value = props.baseX - width.value / 2;
        y.value = props.baseY - height.value / 2;
      }
    });
    expose({
      x,
      y,
      strokeWidth,
      strokeColor,
      strokeDasharray,
      radius,
      width,
      height,
      borderRadius
    });
    return (_ctx, _cache) => {
      return __props.config.type === "circle" ? (openBlock(), createElementBlock("circle", {
        key: 0,
        class: "v-shape-circle",
        cx: x.value,
        cy: y.value,
        r: radius.value,
        fill: __props.config.color,
        stroke: strokeColor.value,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": strokeDasharray.value
      }, null, 8, _hoisted_1$d)) : (openBlock(), createElementBlock("rect", {
        key: 1,
        class: "v-shape-rect",
        x: x.value,
        y: y.value,
        width: width.value,
        height: height.value,
        rx: borderRadius.value,
        ry: borderRadius.value,
        fill: __props.config.color,
        stroke: strokeColor.value,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": strokeDasharray.value
      }, null, 8, _hoisted_2$3));
    };
  }
});
const _hoisted_1$c = ["rx", "ry", "fill", "transform"];
const _hoisted_2$2 = ["x", "y", "font-family", "font-size", "fill"];
const _hoisted_3$2 = ["x", "dy"];
const _sfc_main$k = /* @__PURE__ */ defineComponent({
  props: {
    text: {
      type: String,
      required: true
    },
    x: {
      type: Number,
      required: true
    },
    y: {
      type: Number,
      required: true
    },
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    function updateBackgroundPosition(element2, pos2, transform2) {
      var _a;
      const bbox = element2.getBBox();
      pos2.x = bbox.x;
      pos2.y = bbox.y;
      pos2.width = bbox.width;
      pos2.height = bbox.height;
      transform2.value = (_a = element2.getAttribute("transform")) != null ? _a : void 0;
    }
    function enableMutationObserver(element2, pos2, transform2) {
      const observer2 = new MutationObserver(() => {
        updateBackgroundPosition(element2, pos2, transform2);
      });
      observer2.observe(element2, {
        attributes: true,
        attributeFilter: ["x", "y", "transform", "font-size"]
      });
      updateBackgroundPosition(element2, pos2, transform2);
      return observer2;
    }
    const attrs = useAttrs();
    const { scale } = useZoomLevel();
    const texts = computed(() => props.text.split(/\r?\n/));
    const fontSize = computed(() => {
      var _a;
      return (_a = attrs["font-size"]) != null ? _a : props.config.fontSize * scale.value;
    });
    const lineHeight = computed(() => fontSize.value * props.config.lineHeight);
    const topDeltaY = computed(() => {
      const dominantBaseline = attrs["dominant-baseline"];
      if (dominantBaseline === "hanging") {
        return 0;
      } else if (dominantBaseline === "central") {
        return -(lineHeight.value * (texts.value.length - 1)) / 2;
      } else {
        return -lineHeight.value * (texts.value.length - 1);
      }
    });
    const element = ref();
    const transform = ref("");
    const pos = reactive({ x: 0, y: 0, width: 0, height: 0 });
    const backgroundRectPos = computed(() => {
      var _a, _b;
      const config = props.config.background;
      if (!config)
        return pos;
      let paddingVertical, paddingHorizontal;
      if (config.padding instanceof Object) {
        paddingVertical = config.padding.vertical;
        paddingHorizontal = config.padding.horizontal;
      } else {
        paddingVertical = (_a = config.padding) != null ? _a : 0;
        paddingHorizontal = (_b = config.padding) != null ? _b : 0;
      }
      const lineMargin = lineHeight.value - fontSize.value;
      return {
        x: pos.x - paddingHorizontal * scale.value,
        y: pos.y - paddingVertical * scale.value - lineMargin / 2,
        width: pos.width + paddingHorizontal * 2 * scale.value,
        height: pos.height + paddingVertical * 2 * scale.value + lineMargin
      };
    });
    let observer;
    const updateObserver = () => {
      if (props.config.background && props.config.background.visible) {
        if (!observer && element.value) {
          observer = enableMutationObserver(element.value, pos, transform);
        }
      } else {
        observer == null ? void 0 : observer.disconnect();
        observer = void 0;
      }
    };
    onMounted(() => updateObserver());
    watch(() => props.config.background && props.config.background.visible, (v, prev) => {
      if (v == prev)
        return;
      updateObserver();
    });
    onUnmounted(() => {
      observer == null ? void 0 : observer.disconnect();
      observer = void 0;
    });
    expose({ fontSize, element, transform, backgroundRectPos, scale });
    return (_ctx, _cache) => {
      var _a, _b, _c, _d, _e, _f;
      return openBlock(), createElementBlock(Fragment, null, [
        __props.config.background && __props.config.background.visible ? (openBlock(), createElementBlock("rect", mergeProps({
          key: 0,
          class: "v-text-background"
        }, unref(backgroundRectPos), {
          rx: ((_b = (_a = __props.config.background) == null ? void 0 : _a.borderRadius) != null ? _b : 0) * unref(scale),
          ry: ((_d = (_c = __props.config.background) == null ? void 0 : _c.borderRadius) != null ? _d : 0) * unref(scale),
          fill: (_f = (_e = __props.config.background) == null ? void 0 : _e.color) != null ? _f : "#ffffff",
          transform: transform.value
        }), null, 16, _hoisted_1$c)) : createCommentVNode("", true),
        createElementVNode("text", mergeProps({
          ref: (_value, _refs) => {
            _refs["element"] = _value;
            element.value = _value;
          },
          class: "v-text"
        }, _ctx.$attrs, {
          x: __props.x,
          y: __props.y,
          "font-family": _ctx.$attrs["font-family"] ? `${_ctx.$attrs["font-family"]}` : __props.config.fontFamily,
          "font-size": unref(fontSize),
          fill: _ctx.$attrs.fill ? `${_ctx.$attrs.fill}` : __props.config.color
        }), [
          unref(texts).length <= 1 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString(__props.text), 1)
          ], 64)) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(texts), (t, i) => {
            return openBlock(), createElementBlock("tspan", {
              key: i,
              x: __props.x,
              dy: i == 0 ? unref(topDeltaY) : unref(lineHeight)
            }, toDisplayString(t), 9, _hoisted_3$2);
          }), 128))
        ], 16, _hoisted_2$2)
      ], 64);
    };
  }
});
var node_vue_vue_type_style_index_0_scoped_true_lang = "";
var _export_sfc = (sfc, props) => {
  for (const [key, val] of props) {
    sfc[key] = val;
  }
  return sfc;
};
const _hoisted_1$b = ["transform"];
const _sfc_main$j = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    pos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const x = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.x) || 0;
    });
    const y = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.y) || 0;
    });
    const config = useNodeConfig();
    const { scale } = useZoomLevel();
    const {
      handleNodePointerDownEvent,
      handleNodePointerOverEvent,
      handleNodePointerOutEvent
    } = useMouseOperation();
    const labelVisibility = computed(() => {
      var _a;
      if (props.state.label.visible) {
        return (_a = props.state.labelText) != null ? _a : false;
      }
      return false;
    });
    const labelMargin = computed(() => {
      if (props.state.label.direction === NodeLabelDirection.CENTER) {
        return 0;
      } else {
        return props.state.label.margin * scale.value;
      }
    });
    const labelShiftV = ref(0);
    const labelShiftH = ref(0);
    const labelDiagonalShiftV = ref(0);
    const labelDiagonalShiftH = ref(0);
    watchEffect(() => {
      const s = scale.value;
      const shape = props.state.shape;
      if (shape.type == "circle") {
        const radius = shape.radius * s;
        const m = radius + labelMargin.value;
        const diagonalMargin = Math.sqrt(__pow(m, 2) / 2);
        labelShiftV.value = radius + labelMargin.value;
        labelShiftH.value = radius + labelMargin.value;
        labelDiagonalShiftV.value = diagonalMargin;
        labelDiagonalShiftH.value = diagonalMargin;
      } else {
        const borderRadius = shape.borderRadius * s;
        const width = shape.width * s;
        const height = shape.height * s;
        const m = borderRadius + labelMargin.value;
        const diagonalMargin = Math.sqrt(__pow(m, 2) / 2);
        labelShiftV.value = height / 2 + labelMargin.value;
        labelShiftH.value = width / 2 + labelMargin.value;
        labelDiagonalShiftV.value = height / 2 - borderRadius + diagonalMargin;
        labelDiagonalShiftH.value = width / 2 - borderRadius + diagonalMargin;
      }
    });
    const textAnchor = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.NORTH:
        case NodeLabelDirection.SOUTH:
          return "middle";
        case NodeLabelDirection.EAST:
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.SOUTH_EAST:
          return "start";
        case NodeLabelDirection.WEST:
        case NodeLabelDirection.NORTH_WEST:
        case NodeLabelDirection.SOUTH_WEST:
        default:
          return "end";
      }
    });
    const dominantBaseline = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.NORTH:
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.NORTH_WEST:
          return "text-top";
        case NodeLabelDirection.SOUTH:
        case NodeLabelDirection.SOUTH_EAST:
        case NodeLabelDirection.SOUTH_WEST:
          return "hanging";
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.EAST:
        case NodeLabelDirection.WEST:
        default:
          return "central";
      }
    });
    const labelX = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.NORTH:
        case NodeLabelDirection.SOUTH:
          return 0;
        case NodeLabelDirection.EAST:
          return labelShiftH.value;
        case NodeLabelDirection.WEST:
          return -labelShiftH.value;
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.SOUTH_EAST:
          return labelDiagonalShiftH.value;
        case NodeLabelDirection.NORTH_WEST:
        case NodeLabelDirection.SOUTH_WEST:
        default:
          return -labelDiagonalShiftH.value;
      }
    });
    const labelY = computed(() => {
      switch (props.state.label.direction) {
        case NodeLabelDirection.NORTH:
          return -labelShiftV.value;
        case NodeLabelDirection.SOUTH:
          return labelShiftV.value;
        case NodeLabelDirection.CENTER:
        case NodeLabelDirection.EAST:
        case NodeLabelDirection.WEST:
          return 0;
        case NodeLabelDirection.NORTH_EAST:
        case NodeLabelDirection.NORTH_WEST:
          return -labelDiagonalShiftV.value;
        case NodeLabelDirection.SOUTH_EAST:
        case NodeLabelDirection.SOUTH_WEST:
        default:
          return labelDiagonalShiftV.value;
      }
    });
    expose({
      x,
      y,
      config,
      labelVisibility,
      handleNodePointerDownEvent,
      handleNodePointerOverEvent,
      handleNodePointerOutEvent,
      textAnchor,
      dominantBaseline,
      labelX,
      labelY,
      scale
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", {
        class: normalizeClass({ "v-node": true, hover: __props.state.hovered, selected: __props.state.selected }),
        transform: `translate(${unref(x)} ${unref(y)})`,
        onPointerdown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(handleNodePointerDownEvent)(__props.id, $event), ["prevent", "stop"])),
        onPointerenterPassive: _cache[1] || (_cache[1] = ($event) => unref(handleNodePointerOverEvent)(__props.id, $event)),
        onPointerleavePassive: _cache[2] || (_cache[2] = ($event) => unref(handleNodePointerOutEvent)(__props.id, $event))
      }, [
        renderSlot(_ctx.$slots, "override-node", {
          nodeId: __props.id,
          scale: unref(scale),
          config: __props.state.shape,
          class: normalizeClass({ draggable: __props.state.draggable, selectable: __props.state.selectable })
        }, () => [
          createVNode(_sfc_main$l, {
            config: __props.state.shape,
            class: normalizeClass({ draggable: __props.state.draggable, selectable: __props.state.selectable })
          }, null, 8, ["config", "class"])
        ], true),
        unref(labelVisibility) ? renderSlot(_ctx.$slots, "override-node-label", {
          key: 0,
          nodeId: __props.id,
          scale: unref(scale),
          text: __props.state.labelText,
          x: unref(labelX),
          y: unref(labelY),
          config: __props.state.label,
          shape: __props.state.shape,
          textAnchor: unref(textAnchor),
          dominantBaseline: unref(dominantBaseline)
        }, () => [
          createVNode(_sfc_main$k, {
            text: __props.state.labelText,
            x: unref(labelX),
            y: unref(labelY),
            config: __props.state.label,
            "text-anchor": unref(textAnchor),
            "dominant-baseline": unref(dominantBaseline)
          }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline"])
        ], true) : createCommentVNode("", true)
      ], 42, _hoisted_1$b);
    };
  }
});
var VNode = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-4754dd0c"]]);
var nodeFocusRing_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$i = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    pos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const x = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.x) || 0;
    });
    const y = computed(() => {
      var _a;
      return ((_a = props.pos) == null ? void 0 : _a.y) || 0;
    });
    const config = useNodeConfig();
    const shapeConfig = reactive({});
    watchEffect(() => {
      var _a, _b, _c;
      const shapeStyle = props.state.shape;
      if (shapeStyle.type === "circle") {
        const shape = {
          type: "circle",
          radius: shapeStyle.radius + ((_a = shapeStyle.strokeWidth) != null ? _a : 0) / 2 + config.focusring.padding + config.focusring.width / 2,
          color: "none",
          strokeWidth: config.focusring.width,
          strokeColor: config.focusring.color,
          strokeDasharray: config.focusring.dasharray
        };
        Object.assign(shapeConfig, shape);
      } else {
        const shape = {
          type: "rect",
          width: shapeStyle.width + ((_b = shapeStyle.strokeWidth) != null ? _b : 0) + config.focusring.padding * 2 + config.focusring.width,
          height: shapeStyle.height + ((_c = shapeStyle.strokeWidth) != null ? _c : 0) + config.focusring.padding * 2 + config.focusring.width,
          borderRadius: shapeStyle.borderRadius > 0 ? shapeStyle.borderRadius + config.focusring.padding : 0,
          color: "none",
          strokeWidth: config.focusring.width,
          strokeColor: config.focusring.color,
          strokeDasharray: config.focusring.dasharray
        };
        Object.assign(shapeConfig, shape);
      }
    });
    expose({ x, y, shapeConfig });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$l, {
        class: "v-node-focus-ring",
        "base-x": unref(x),
        "base-y": unref(y),
        config: unref(shapeConfig)
      }, null, 8, ["base-x", "base-y", "config"]);
    };
  }
});
var VNodeFocusRing = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-4f2bee14"]]);
var line_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$a = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap"];
const _sfc_main$h = /* @__PURE__ */ defineComponent({
  props: {
    x1: {
      type: Number,
      required: true
    },
    y1: {
      type: Number,
      required: true
    },
    x2: {
      type: Number,
      required: true
    },
    y2: {
      type: Number,
      required: true
    },
    config: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const strokeWidth = computed(() => {
      return props.config.width * scale.value;
    });
    const strokeDasharray = computed(() => {
      return applyScaleToDasharray(props.config.dasharray, scale.value);
    });
    const animationSpeed = computed(() => {
      const speed = props.config.animate ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value : false;
      return speed ? `--animation-speed:${speed}` : void 0;
    });
    expose({ strokeWidth, strokeDasharray, animationSpeed });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-line": true, animate: __props.config.animate }),
        d: `M ${__props.x1} ${__props.y1} L ${__props.x2} ${__props.y2}`,
        stroke: __props.config.color,
        "stroke-width": unref(strokeWidth),
        "stroke-dasharray": unref(strokeDasharray),
        "stroke-linecap": __props.config.linecap,
        style: normalizeStyle(unref(animationSpeed))
      }, null, 14, _hoisted_1$a);
    };
  }
});
var VLine = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-1809a5d0"]]);
function baseSlice(array, start, end) {
  var index = -1, length = array.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}
var nativeCeil = Math.ceil, nativeMax = Math.max;
function chunk(array, size, guard) {
  if (guard ? isIterateeCall(array, size, guard) : size === void 0) {
    size = 1;
  } else {
    size = nativeMax(toInteger(size), 0);
  }
  var length = array == null ? 0 : array.length;
  if (!length || size < 1) {
    return [];
  }
  var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
  while (index < length) {
    result[resIndex++] = baseSlice(array, index, index += size);
  }
  return result;
}
var edgeCurved_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$9 = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "marker-start", "marker-end"];
const _sfc_main$g = /* @__PURE__ */ defineComponent({
  props: {
    state: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    markerStart: {
      type: String,
      required: false,
      default: void 0
    },
    markerEnd: {
      type: String,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const pathD = computed(() => {
      var _a, _b;
      const p = props.state.position;
      const points = [...(_b = (_a = props.state.curve) == null ? void 0 : _a.control) != null ? _b : [], { x: p.x2, y: p.y2 }];
      const d = [];
      d.push(`M ${p.x1} ${p.y1}`);
      chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));
      return d.join(" ");
    });
    const strokeWidth = computed(() => {
      return props.config.width * scale.value;
    });
    const strokeDasharray = computed(() => {
      return applyScaleToDasharray(props.config.dasharray, scale.value);
    });
    const animationSpeed = computed(() => {
      const speed = props.config.animate ? getDasharrayUnit(props.config.dasharray) * props.config.animationSpeed * scale.value : false;
      return speed ? `--animation-speed:${speed}` : void 0;
    });
    expose({ strokeWidth, strokeDasharray, animationSpeed });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-line": true, animate: __props.config.animate }),
        d: unref(pathD),
        fill: "none",
        stroke: __props.config.color,
        "stroke-width": unref(strokeWidth),
        "stroke-dasharray": unref(strokeDasharray),
        "stroke-linecap": __props.config.linecap,
        style: normalizeStyle(unref(animationSpeed)),
        "marker-start": __props.markerStart,
        "marker-end": __props.markerEnd
      }, null, 14, _hoisted_1$9);
    };
  }
});
var VEdgeCurved = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-1fa4fd0c"]]);
var edge_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$f = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    sourcePos: {
      type: Object,
      required: false,
      default: void 0
    },
    targetPos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const config = useEdgeConfig();
    expose({ config });
    return (_ctx, _cache) => {
      return unref(config).type == "straight" || !__props.state.curve ? (openBlock(), createBlock(VLine, mergeProps({ key: 0 }, __props.state.position, {
        class: { selectable: __props.state.selectable, hover: __props.state.hovered, selected: __props.state.selected },
        config: __props.state.line.stroke,
        "marker-start": __props.state.sourceMarkerId ? `url(#${__props.state.sourceMarkerId})` : void 0,
        "marker-end": __props.state.targetMarkerId ? `url(#${__props.state.targetMarkerId})` : void 0
      }), null, 16, ["class", "config", "marker-start", "marker-end"])) : (openBlock(), createBlock(VEdgeCurved, {
        key: 1,
        class: normalizeClass({ selectable: __props.state.selectable, hover: __props.state.hovered, selected: __props.state.selected }),
        state: __props.state,
        config: __props.state.line.stroke,
        "marker-start": __props.state.sourceMarkerId ? `url(#${__props.state.sourceMarkerId})` : void 0,
        "marker-end": __props.state.targetMarkerId ? `url(#${__props.state.targetMarkerId})` : void 0
      }, null, 8, ["class", "state", "config", "marker-start", "marker-end"]));
    };
  }
});
var VEdge = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-7a62c7be"]]);
const _sfc_main$e = /* @__PURE__ */ defineComponent({
  props: {
    edges: {
      type: Object,
      required: true
    },
    layouts: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const config = useEdgeConfig();
    const { edgeStates } = useStates();
    const pos = ref({ x1: 0, y1: 0, x2: 0, y2: 0 });
    const centerPos = ref({ x: 0, y: 0 });
    watchEffect(() => {
      const edgeId = Object.keys(props.edges)[0];
      pos.value = edgeStates[edgeId].position;
      centerPos.value = {
        x: (pos.value.x1 + pos.value.x2) / 2,
        y: (pos.value.y1 + pos.value.y2) / 2
      };
    });
    expose({ config, pos, centerPos });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", null, [
        createVNode(VLine, mergeProps(pos.value, {
          config: unref(config).summarized.stroke
        }), null, 16, ["config"]),
        createVNode(_sfc_main$l, {
          "base-x": centerPos.value.x,
          "base-y": centerPos.value.y,
          config: unref(config).summarized.shape
        }, null, 8, ["base-x", "base-y", "config"]),
        createVNode(_sfc_main$k, {
          text: Object.keys(__props.edges).length.toString(),
          x: centerPos.value.x,
          y: centerPos.value.y,
          config: unref(config).summarized.label,
          "text-anchor": "middle",
          "dominant-baseline": "central"
        }, null, 8, ["text", "x", "y", "config"])
      ]);
    };
  }
});
const _sfc_main$d = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { edgeStates, edgeGroupStates, layouts } = useStates();
    expose({ edgeStates, edgeGroupStates, layouts });
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroupStates).edgeGroups, ({ summarize, edges }, key) => {
        return openBlock(), createElementBlock(Fragment, null, [
          summarize ? (openBlock(), createBlock(_sfc_main$e, {
            key,
            edges,
            layouts: unref(layouts).nodes
          }, null, 8, ["edges", "layouts"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(edges, (edge, id) => {
            return openBlock(), createBlock(VEdge, {
              key: id,
              id,
              state: unref(edgeStates)[id],
              "source-pos": unref(layouts).nodes[edge.source],
              "target-pos": unref(layouts).nodes[edge.target]
            }, null, 8, ["id", "state", "source-pos", "target-pos"]);
          }), 128))
        ], 64);
      }), 256);
    };
  }
});
var edgeBackground_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$8 = ["d", "stroke-width"];
const _sfc_main$c = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    state: {
      type: Object,
      required: true
    },
    sourcePos: {
      type: Object,
      required: false,
      default: void 0
    },
    targetPos: {
      type: Object,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const config = useEdgeConfig();
    const {
      handleEdgePointerDownEvent,
      handleEdgePointerOverEvent,
      handleEdgePointerOutEvent
    } = useMouseOperation();
    const pathD = computed(() => {
      const p = props.state.position;
      if (config.type === "straight" || !props.state.curve) {
        return `M ${p.x1} ${p.y1} L ${p.x2} ${p.y2}`;
      } else {
        const points = [...props.state.curve.control, { x: p.x2, y: p.y2 }];
        const d = [];
        d.push(`M ${p.x1} ${p.y1}`);
        chunk(points, 2).forEach(([p1, p2]) => d.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));
        return d.join(" ");
      }
    });
    const strokeWidth = computed(() => (props.state.line.stroke.width + 10) * scale.value);
    expose({
      config,
      handleEdgePointerDownEvent,
      handleEdgePointerOverEvent,
      handleEdgePointerOutEvent
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-line-background": true, selectable: __props.state.selectable }),
        d: unref(pathD),
        stroke: "transparent",
        "stroke-width": unref(strokeWidth),
        fill: "none",
        onPointerdown: _cache[0] || (_cache[0] = withModifiers(($event) => unref(handleEdgePointerDownEvent)(__props.id, $event), ["prevent", "stop"])),
        onPointerenterPassive: _cache[1] || (_cache[1] = ($event) => unref(handleEdgePointerOverEvent)(__props.id, $event)),
        onPointerleavePassive: _cache[2] || (_cache[2] = ($event) => unref(handleEdgePointerOutEvent)(__props.id, $event))
      }, null, 42, _hoisted_1$8);
    };
  }
});
var VEdgeBackground = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-7730d87a"]]);
const _sfc_main$b = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { edgeStates, edgeGroupStates, layouts } = useStates();
    expose({ edgeStates, edgeGroupStates, layouts });
    return (_ctx, _cache) => {
      return openBlock(true), createElementBlock(Fragment, null, renderList(unref(edgeGroupStates).edgeGroups, ({ summarize, edges }) => {
        return openBlock(), createElementBlock(Fragment, null, [
          !summarize ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(edges, (edge, id) => {
            return openBlock(), createBlock(VEdgeBackground, {
              key: id,
              id,
              state: unref(edgeStates)[id],
              "source-pos": unref(layouts).nodes[edge.source],
              "target-pos": unref(layouts).nodes[edge.target]
            }, null, 8, ["id", "state", "source-pos", "target-pos"]);
          }), 128)) : createCommentVNode("", true)
        ], 64);
      }), 256);
    };
  }
});
var edgeLabels_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$7 = { class: "v-edge-labels" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const edgeConfig = useEdgeConfig();
    const { nodeStates, edgeStates, edgeGroupStates, layouts } = useStates();
    const { scale } = useZoomLevel();
    const indivisualEdgeGroups = computed(() => Object.fromEntries(Object.entries(edgeGroupStates.edgeGroups).filter(([_, group]) => !group.summarize && Object.keys(group.edges).length > 0)));
    const labelAreaPosition = computed(() => (edgeId, source, target, edgeStyle) => {
      return calculateEdgeLabelArea(edgeStates[edgeId].labelPosition, edgeStyle, edgeConfig.label.margin, edgeConfig.label.padding, scale.value);
    });
    const nodeShape = computed(() => (node) => {
      var _a;
      return {
        pos: (_a = layouts.nodes[node]) != null ? _a : { x: 0, y: 0 },
        shape: nodeStates[node].shape
      };
    });
    expose({
      indivisualEdgeGroups,
      labelAreaPosition,
      nodeShape,
      edgeStates,
      edgeConfig,
      scale
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", _hoisted_1$7, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(indivisualEdgeGroups), (group, id) => {
          return openBlock(), createElementBlock(Fragment, { key: id }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(group.edges, (edge, edgeId) => {
              return renderSlot(_ctx.$slots, "edge-label", {
                key: edgeId,
                edgeId,
                edge,
                config: unref(edgeConfig).label,
                area: unref(labelAreaPosition)(edgeId, unref(nodeShape)(edge.source), unref(nodeShape)(edge.target), unref(edgeStates)[edgeId].line.stroke),
                hovered: unref(edgeStates)[edgeId].hovered,
                selected: unref(edgeStates)[edgeId].selected,
                scale: unref(scale)
              }, void 0, true);
            }), 128))
          ], 64);
        }), 128))
      ]);
    };
  }
});
var VEdgeLabels = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-260bb874"]]);
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { svg } = useContainers();
    const background = ref();
    const viewport = ref();
    const updateAttributes = (attrs, bgLayer, vpLayer) => {
      attrs.forEach((attr) => {
        var _a;
        return bgLayer.setAttribute(attr, (_a = vpLayer.getAttribute(attr)) != null ? _a : "");
      });
    };
    const observer = new MutationObserver((records) => {
      if (!background.value || !viewport.value)
        return;
      const attrs = records.map((r) => {
        var _a;
        return (_a = r.attributeName) != null ? _a : "";
      }).filter(Boolean);
      updateAttributes(attrs, background.value, viewport.value);
    });
    onMounted(() => {
      const vp = nonNull(svg.value.querySelector(".v-viewport"), "v-viewport");
      viewport.value = vp;
      const attrs = ["transform", "style"];
      observer.observe(viewport.value, {
        attributes: true,
        attributeFilter: attrs
      });
      if (!background.value)
        return;
      updateAttributes(attrs, background.value, vp);
    });
    onUnmounted(() => {
      observer.disconnect();
    });
    expose({ background });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", {
        ref: (_value, _refs) => {
          _refs["background"] = _value;
          background.value = _value;
        },
        class: "v-background-viewport"
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 512);
    };
  }
});
var backgroundGrid_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$6 = {
  class: "v-background-grid",
  "shape-rendering": "crispEdges"
};
const _hoisted_2$1 = ["d"];
const _hoisted_3$1 = ["d"];
const _hoisted_4$1 = ["d"];
const _hoisted_5$1 = ["d"];
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  setup(__props, { expose }) {
    const { emitter } = useEventEmitter();
    const { container, svgPanZoom: svgPanZoom2 } = useContainers();
    const { scale } = useZoomLevel();
    const config = useViewConfig();
    const basePoint = ref({ x: 0, y: 0 });
    const viewport = ref({ width: 500, height: 500 });
    onMounted(() => {
      var _a;
      const pan = (_a = svgPanZoom2.value) == null ? void 0 : _a.getPan();
      if (pan) {
        basePoint.value = {
          x: -pan.x,
          y: -pan.y
        };
      }
      const rect = container.value.getBoundingClientRect();
      viewport.value = {
        width: rect.width,
        height: rect.height
      };
    });
    emitter.on("view:resize", (rect) => {
      viewport.value = { width: rect.width, height: rect.height };
    });
    emitter.on("view:pan", (pan) => {
      basePoint.value = { x: -pan.x, y: -pan.y };
    });
    emitter.on("view:zoom", () => {
      var _a;
      const pan = (_a = svgPanZoom2.value) == null ? void 0 : _a.getPan();
      if (pan) {
        basePoint.value = { x: -pan.x, y: -pan.y };
      }
    });
    const thickVerticals = ref([]);
    const thickHorizontals = ref([]);
    const normalVerticals = ref([]);
    const normalHorizontals = ref([]);
    watchEffect(() => {
      const thickH = [];
      const thickV = [];
      const normalH = [];
      const normalV = [];
      const s = scale.value;
      const gi = config.grid.interval;
      const x = basePoint.value.x * s;
      const y = basePoint.value.y * s;
      const width = Math.floor(viewport.value.width / gi + 1) * gi;
      const height = Math.floor(viewport.value.height / gi + 1) * gi;
      const maxWidth = (basePoint.value.x + width) * s;
      const maxHeight = (basePoint.value.y + height) * s;
      const inc = config.grid.thickIncrements;
      const normalDasharray = config.grid.line.dasharray;
      const thickDasharray = config.grid.thick.dasharray;
      let thickAttrs = {
        stroke: config.grid.thick.color,
        "stroke-width": config.grid.thick.width,
        "stroke-dasharray": thickDasharray,
        "stroke-dashoffset": thickDasharray ? x / s : void 0
      };
      let normalAttrs = {
        stroke: config.grid.line.color,
        "stroke-width": config.grid.line.width,
        "stroke-dasharray": normalDasharray,
        "stroke-dashoffset": normalDasharray ? x / s : void 0
      };
      const w = (basePoint.value.x + width) * s;
      for (let i = y; i <= maxHeight; i += gi) {
        const index = Math.floor(i / gi);
        if (inc && index % inc === 0) {
          thickH.push([index, index * gi, x, w, thickAttrs]);
        } else {
          normalH.push([index, index * gi, x, w, normalAttrs]);
        }
      }
      thickAttrs = __spreadValues({}, thickAttrs);
      thickAttrs["stroke-dashoffset"] = thickDasharray ? y / s : void 0;
      normalAttrs = __spreadValues({}, normalAttrs);
      normalAttrs["stroke-dashoffset"] = normalDasharray ? y / s : void 0;
      const h = (basePoint.value.y + height) * s;
      for (let i = x; i <= maxWidth; i += gi) {
        const index = Math.floor(i / gi);
        if (inc && index % inc === 0) {
          thickV.push([index, index * gi, y, h, thickAttrs]);
        } else {
          normalV.push([index, index * gi, y, h, normalAttrs]);
        }
      }
      thickHorizontals.value = thickH;
      thickVerticals.value = thickV;
      normalHorizontals.value = normalH;
      normalVerticals.value = normalV;
    });
    expose({
      thickVerticals,
      thickHorizontals,
      normalVerticals,
      normalHorizontals
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("g", _hoisted_1$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(normalHorizontals.value, ([i, v, x, w, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `nv${i}`,
            d: `M ${x} ${v} L ${w} ${v}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_2$1);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(normalVerticals.value, ([i, v, y, h, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `nh${i}`,
            d: `M ${v} ${y} L ${v} ${h}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_3$1);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(thickHorizontals.value, ([i, v, x, w, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `tv${i}`,
            d: `M ${x} ${v} L ${w} ${v}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_4$1);
        }), 128)),
        (openBlock(true), createElementBlock(Fragment, null, renderList(thickVerticals.value, ([i, v, y, h, attrs]) => {
          return openBlock(), createElementBlock("path", mergeProps({
            key: `th${i}`,
            d: `M ${v} ${y} L ${v} ${h}`
          }, attrs, { style: { "vector-effect": "non-scaling-stroke" } }), null, 16, _hoisted_5$1);
        }), 128))
      ]);
    };
  }
});
var pathLine_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$5 = ["d", "stroke", "stroke-width", "stroke-dasharray", "stroke-linecap", "stroke-linejoin"];
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  props: {
    points: {
      type: Array,
      required: true
    },
    path: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const { scale } = useZoomLevel();
    const pathConfig = usePathConfig();
    const d = computed(() => {
      let move = true;
      return props.points.map((p) => {
        if (p === null) {
          move = true;
        } else if (p instanceof Array) {
          p = [...p];
          const list = [];
          if (p.length % 2 === 1) {
            const x = p[0];
            p = p.slice(1);
            list.push(`L ${x.x} ${x.y}`);
          }
          chunk(p, 2).map(([p1, p2]) => list.push(`Q ${p1.x} ${p1.y} ${p2.x} ${p2.y}`));
          return list.join(" ");
        } else {
          const m = move;
          move = false;
          return `${m ? "M " : "L "}${p.x} ${p.y}`;
        }
      }).join(" ");
    });
    const config = computed(() => {
      return Config.values(pathConfig.path, props.path);
    });
    const strokeDasharray = computed(() => {
      return applyScaleToDasharray(config.value.dasharray, scale.value);
    });
    const animationSpeed = computed(() => {
      const speed = config.value.animate ? getDasharrayUnit(config.value.dasharray) * config.value.animationSpeed * scale.value : false;
      return speed ? `--animation-speed:${speed}` : void 0;
    });
    expose({ d, scale, config, strokeDasharray, animationSpeed });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("path", {
        class: normalizeClass({ "v-path-line": true, animate: unref(config).animate }),
        d: unref(d),
        fill: "none",
        stroke: unref(config).color,
        "stroke-width": unref(config).width * unref(scale),
        "stroke-dasharray": unref(strokeDasharray),
        "stroke-linecap": unref(config).linecap,
        "stroke-linejoin": unref(config).linejoin,
        style: normalizeStyle(unref(animationSpeed))
      }, null, 14, _hoisted_1$5);
    };
  }
});
var VPathLine = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-d5817f5c"]]);
var paths_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  props: {
    paths: {
      type: Array,
      required: true
    },
    edges: {
      type: Object,
      required: true
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const EPSILON = Number.EPSILON * 100;
    const pathConfig = usePathConfig();
    const { nodeStates, edgeStates, layouts } = useStates();
    const { scale } = useZoomLevel();
    const { emitter } = useEventEmitter();
    const pathList = computed(() => {
      const list = [];
      for (const path of props.paths) {
        const edges = path.edges.map((edgeId) => ({ edgeId, edge: props.edges[edgeId] })).filter((e) => e.edge);
        if (edges.length !== path.edges.length) {
          continue;
        }
        list.push({ path, edges });
      }
      return list;
    });
    const calcPathPoints = computed(() => (path) => {
      if (path.edges.length === 0)
        return [];
      const margin = Config.value(pathConfig.margin, path.path) * scale.value;
      return _calculatePathPoints(path, nodeStates, layouts.nodes, edgeStates, scale.value, pathConfig.curveInNode, pathConfig.end, margin);
    });
    const emitPathClicked = (path) => {
      if (!pathConfig.clickable)
        return;
      emitter.emit("path:click", path);
    };
    function _calculatePathPoints(path, nodeStates2, nodeLayouts, edgeStates2, scale2, curveInNode, pathEndType, margin) {
      var _a;
      const edges = path.edges;
      const directions = _detectDirectionsOfPathEdges(edges);
      const edgePos = edges.map((edge, i) => _getEdgeLine(edge, directions[i], edgeStates2[edge.edgeId]));
      const points = [];
      let isMarginOverRunStart = false;
      let isMarginOverRunEnd = false;
      {
        const firstEdge = edgePos[0];
        let nodeRadius = _getNodeRadius(nodeStates2[firstEdge.source].shape) * scale2;
        const lineMargin = margin + (pathEndType === "edgeOfNode" ? nodeRadius : 0);
        const nextPoint = lineMargin <= 0 ? firstEdge.line.source : _calculateEdgeOfNode(firstEdge, lineMargin, nodeLayouts, true);
        points.push(nextPoint);
        nodeRadius = _getNodeRadius(nodeStates2[firstEdge.target].shape) * scale2;
        if (margin > 0) {
          const distance = calculateDistance(firstEdge.line.source, firstEdge.line.target);
          if (distance <= lineMargin + nodeRadius) {
            isMarginOverRunStart = true;
          }
        }
      }
      const length = edges.length;
      for (let i = 1; i < length; i++) {
        const prev = edgePos[i - 1];
        const next = edgePos[i];
        const nodeId = next.source;
        const nodePos = Vector.fromObject((_a = nodeLayouts[nodeId]) != null ? _a : { x: 0, y: 0 });
        const crossPoint = _getIntersectionOfLines(prev, next, nodePos);
        const nodeRadius = _getNodeRadius(nodeStates2[nodeId].shape) * scale2;
        const nodeCoreRadius = Math.max(nodeRadius * (2 / 3), nodeRadius - 4 * scale2);
        const prevCoreIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeCoreRadius, true);
        const nextCoreIp = _getIntersectionOfLineAndNode(next, nodePos, nodeCoreRadius, false);
        const prevNodeIp = _getIntersectionOfLineAndNode(prev, nodePos, nodeRadius, true);
        const nextNodeIp = _getIntersectionOfLineAndNode(next, nodePos, nodeRadius, false);
        let pos;
        if (crossPoint) {
          const d = calculateDistance(crossPoint, nodePos);
          if (d < nodeCoreRadius) {
            pos = [
              findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),
              crossPoint,
              findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source)
            ];
          } else if (d <= nodeRadius) {
            let p1, p2;
            if (prevNodeIp && prevCoreIp) {
              p1 = calculateDistance(crossPoint, prevCoreIp) < calculateDistance(crossPoint, prevNodeIp) ? prevCoreIp : prevNodeIp;
            } else {
              p1 = prevNodeIp || prev.line.target;
            }
            if (nextNodeIp && nextCoreIp) {
              p2 = calculateDistance(crossPoint, nextCoreIp) < calculateDistance(crossPoint, nextNodeIp) ? nextCoreIp : nextNodeIp;
            } else {
              p2 = nextNodeIp || next.line.source;
            }
            pos = [p1, crossPoint, p2];
          } else {
            if (prevCoreIp && nextCoreIp) {
              pos = [prevCoreIp, nodePos, nextCoreIp];
            } else if (prevNodeIp && nextNodeIp) {
              pos = [prevNodeIp, nodePos, nextNodeIp];
            } else {
              pos = [
                findFirstNonNull(prevCoreIp, prevNodeIp, prev.line.target),
                nodePos,
                findFirstNonNull(nextCoreIp, nextNodeIp, next.line.source)
              ];
            }
          }
        } else {
          if (prevCoreIp && nextCoreIp) {
            pos = [prevCoreIp, nodePos, nextCoreIp];
          } else if (prevNodeIp && nextNodeIp) {
            pos = [prevNodeIp, nodePos, nextNodeIp];
          } else {
            pos = [prev.line.target, nodePos, next.line.source];
          }
        }
        if (prev.curve) {
          const lastPoints = points[points.length - 1];
          if (lastPoints) {
            const lastPoint = lastPoints instanceof Array ? lastPoints[lastPoints.length - 1] : lastPoints;
            let nextPoint;
            if (pos instanceof Array) {
              nextPoint = curveInNode ? pos[0] : pos[1];
            } else {
              nextPoint = pos;
            }
            const control = calculateBezierCurveControlPoint(lastPoint, prev.curve.circle.center, nextPoint, prev.curve.theta);
            if (pos instanceof Array && curveInNode) {
              points.push([...control, ...pos]);
            } else {
              points.push([...control, nextPoint]);
            }
          }
        } else {
          if (curveInNode || !(pos instanceof Array)) {
            points.push(pos);
          } else {
            if (next.curve) {
              points.push(pos[1]);
            } else {
              points.push(pos[0], pos[2]);
            }
          }
        }
      }
      {
        const lastEdge = edgePos[edgePos.length - 1];
        let nodeRadius = _getNodeRadius(nodeStates2[lastEdge.target].shape) * scale2;
        const lineMargin = margin + (pathEndType === "edgeOfNode" ? nodeRadius : 0);
        const nextPoint = lineMargin <= 0 ? lastEdge.line.target : _calculateEdgeOfNode(lastEdge, lineMargin, nodeLayouts, false);
        nodeRadius = _getNodeRadius(nodeStates2[lastEdge.source].shape) * scale2;
        const curve = lastEdge.curve;
        if (curve) {
          const pos = points[points.length - 1];
          const lastPoint = pos instanceof Array ? pos[pos.length - 1] : pos;
          const control = calculateBezierCurveControlPoint(lastPoint, curve.circle.center, nextPoint, curve.theta);
          points.push([...control, nextPoint]);
        } else {
          points.push(nextPoint);
        }
        if (margin > 0) {
          const distance = calculateDistance(lastEdge.line.source, lastEdge.line.target);
          if (distance <= lineMargin + nodeRadius) {
            isMarginOverRunEnd = true;
          }
        }
      }
      if (isMarginOverRunStart) {
        points.shift();
        if (points[0] instanceof Array) {
          points.unshift(points[0][0]);
        }
      }
      if (isMarginOverRunEnd) {
        points.pop();
      }
      return points;
    }
    function _getNodeRadius(shape) {
      if (shape.type == "circle") {
        return shape.radius;
      } else {
        return Math.min(shape.width, shape.height) / 2;
      }
    }
    function _detectDirectionsOfPathEdges(edges) {
      const length = edges.length;
      if (length <= 1) {
        return [true];
      }
      const directions = [];
      let lastNode = null;
      for (let i = 0; i < length; i++) {
        const source = edges[i].edge.source;
        const target = edges[i].edge.target;
        let isForward;
        if (i === 0) {
          if (length > 2) {
            const edge0 = [source, target].sort();
            const edge1 = [edges[1].edge.source, edges[1].edge.target].sort();
            if (edge0[0] === edge1[0] && edge0[1] === edge1[1]) {
              const next = [edges[2].edge.source, edges[2].edge.target];
              if (next.includes(edges[1].edge.target)) {
                isForward = target === edges[1].edge.source;
              } else {
                isForward = target === edges[1].edge.target;
              }
            } else {
              isForward = [edges[1].edge.source, edges[1].edge.target].includes(target);
            }
          } else {
            isForward = [edges[1].edge.source, edges[1].edge.target].includes(target);
          }
        } else {
          isForward = lastNode === source;
        }
        directions.push(isForward);
        lastNode = isForward ? target : source;
      }
      return directions;
    }
    function _calculateEdgeOfNode(edge, nodeRadius, nodeLayouts, direction) {
      const nodeId = direction ? edge.source : edge.target;
      const curve = edge.curve;
      if (curve) {
        let moveRad = nodeRadius / curve.circle.radius;
        if (curve.theta > 0) {
          moveRad *= -1;
        }
        if (!direction) {
          moveRad *= -1;
        }
        return Vector.fromObject(moveOnCircumference(direction ? edge.line.source : edge.line.target, curve.circle.center, moveRad));
      } else {
        let source, target;
        if (direction) {
          source = edge.line.target;
          target = edge.line.source;
        } else {
          source = edge.line.source;
          target = edge.line.target;
        }
        const p = getIntersectionOfLineTargetAndCircle(source, target, Vector.fromObject(nodeLayouts[nodeId]), nodeRadius);
        return p === null ? source : p;
      }
    }
    function _getIntersectionOfLines(prev, next, nodePos) {
      let crossPoint = null;
      if (prev.curve) {
        if (next.curve) {
          if (prev.line.target.isEqualTo(next.line.source)) {
            return prev.line.target.clone();
          }
          crossPoint = getIntersectionOfCircles(prev.curve.circle.center, prev.curve.circle.radius, next.curve.circle.center, next.curve.circle.radius, prev.curve.center);
        } else {
          crossPoint = getIntersectionOfLineTargetAndCircle2(next.line.target, next.line.source, prev.curve.circle.center, prev.curve.circle.radius, nodePos);
        }
      } else {
        if (next.curve) {
          crossPoint = getIntersectionOfLineTargetAndCircle(prev.line.source, prev.line.target, next.curve.circle.center, next.curve.circle.radius);
        } else {
          const prevSlope = _getSlope(prev.line);
          const nextSlope = _getSlope(next.line);
          const isParallel = !isFinite(prevSlope) && !isFinite(nextSlope) || Math.abs(prevSlope - nextSlope) < EPSILON;
          if (isParallel) {
            crossPoint = null;
          } else {
            crossPoint = getIntersectionPointOfLines(prev.line, next.line);
          }
        }
      }
      return crossPoint;
    }
    function _getIntersectionOfLineAndNode(edge, nodeCenter, nodeRadius, targetSide) {
      if (edge.curve) {
        return getIntersectionOfCircles(nodeCenter, nodeRadius, edge.curve.circle.center, edge.curve.circle.radius, Vector.fromObject(edge.curve.center));
      } else {
        return getIntersectionOfLineTargetAndCircle(targetSide ? edge.line.source : edge.line.target, targetSide ? edge.line.target : edge.line.source, nodeCenter, nodeRadius);
      }
    }
    function _getEdgeLine(edge, direction, state) {
      let position = state.origin;
      let source = edge.edge.source;
      let target = edge.edge.target;
      let curve = state.curve;
      if (!direction) {
        position = inverseLine(position);
        source = edge.edge.target;
        target = edge.edge.source;
        if (curve) {
          curve = __spreadProps(__spreadValues({}, curve), { theta: -curve.theta });
        }
      }
      const line = fromLinePosition(position);
      const result = {
        edgeId: edge.edgeId,
        source,
        target,
        line,
        curve
      };
      return result;
    }
    function _getSlope(pos) {
      return (pos.target.y - pos.source.y) / (pos.target.x - pos.source.x);
    }
    expose({ pathConfig, pathList, calcPathPoints, emitPathClicked });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(TransitionGroup, {
        name: unref(pathConfig).transition,
        css: !!unref(pathConfig).transition,
        tag: "g",
        class: "v-paths"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(pathList), (path, i) => {
            return openBlock(), createBlock(VPathLine, {
              key: i,
              points: unref(calcPathPoints)(path),
              class: normalizeClass({ clickable: unref(pathConfig).clickable }),
              path: path.path,
              onClick: withModifiers(($event) => emitPathClicked(path.path), ["prevent", "stop"])
            }, null, 8, ["points", "class", "path", "onClick"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["name", "css"]);
    };
  }
});
var VPaths = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-3bbe2e44"]]);
const _hoisted_1$4 = ["points", "fill"];
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  props: {
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    refX: {
      type: Number,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    isSource: {
      type: Boolean,
      required: true
    },
    units: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const arrowPoints = computed(() => {
      const w = props.width;
      const h = props.height;
      if (props.isSource) {
        return `${w} ${h}, 0 ${h / 2}, ${w} 0`;
      } else {
        return `0 0, ${w} ${h / 2}, 0 ${h}`;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("polygon", {
        points: unref(arrowPoints),
        fill: __props.color
      }, null, 8, _hoisted_1$4);
    };
  }
});
const _hoisted_1$3 = ["points", "stroke-width", "stroke"];
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  props: {
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    refX: {
      type: Number,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    isSource: {
      type: Boolean,
      required: true
    },
    units: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const angleStroke = computed(() => {
      return props.units === "strokeWidth" ? 1 : Math.min(props.width, props.height) / 5;
    });
    const anglePoints = computed(() => {
      const m = angleStroke.value / 2;
      const w = props.width;
      const h = props.height;
      if (props.isSource) {
        return `${w - m} ${h - m}, ${m} ${h / 2}, ${w - m} ${m}`;
      } else {
        return `${m} ${m}, ${w - m} ${h / 2}, ${m} ${h - m}`;
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("polyline", {
        points: unref(anglePoints),
        fill: "none",
        "stroke-width": unref(angleStroke),
        stroke: __props.color,
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      }, null, 8, _hoisted_1$3);
    };
  }
});
const _hoisted_1$2 = ["fill", "cx", "cy", "rx", "ry"];
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  props: {
    width: {
      type: Number,
      required: true
    },
    height: {
      type: Number,
      required: true
    },
    refX: {
      type: Number,
      required: true
    },
    color: {
      type: String,
      required: true
    },
    isSource: {
      type: Boolean,
      required: true
    },
    units: {
      type: String,
      required: true
    }
  },
  setup(__props) {
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("ellipse", {
        fill: __props.color,
        cx: __props.width / 2,
        cy: __props.height / 2,
        rx: __props.width / 2,
        ry: __props.height / 2
      }, null, 8, _hoisted_1$2);
    };
  }
});
const _hoisted_1$1 = ["id", "markerWidth", "markerHeight", "refX", "refY", "markerUnits"];
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  props: {
    id: {
      type: String,
      required: true
    },
    marker: {
      type: Object,
      required: true
    },
    scale: {
      type: Number,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const types = {
      arrow: _sfc_main$5,
      angle: _sfc_main$4,
      circle: _sfc_main$3
    };
    const width = computed(() => props.marker.width * (props.marker.units === "strokeWidth" ? 1 : props.scale));
    const height = computed(() => props.marker.height * (props.marker.units === "strokeWidth" ? 1 : props.scale));
    const refX = computed(() => {
      const margin = props.marker.margin * (props.marker.units === "strokeWidth" ? 1 : props.scale);
      return props.marker.isSource ? width.value + margin : -margin;
    });
    return (_ctx, _cache) => {
      return __props.marker.type !== "none" && __props.marker.type !== "custom" ? (openBlock(), createElementBlock("marker", {
        key: 0,
        id: __props.id,
        markerWidth: unref(width),
        markerHeight: unref(height),
        refX: unref(refX),
        refY: unref(height) / 2,
        orient: "auto",
        markerUnits: __props.marker.units,
        class: "v-marker"
      }, [
        (openBlock(), createBlock(resolveDynamicComponent(types[__props.marker.type]), {
          width: unref(width),
          height: unref(height),
          refX: unref(refX),
          color: __props.marker.color,
          "is-source": __props.marker.isSource,
          units: __props.marker.units
        }, null, 8, ["width", "height", "refX", "color", "is-source", "units"]))
      ], 8, _hoisted_1$1)) : createCommentVNode("", true);
    };
  }
});
var networkGraph_vue_vue_type_style_index_0_scoped_true_lang = "";
const SYSTEM_SLOTS = ["override-node", "override-node-label", "edge-label"];
const _sfc_main$1 = defineComponent({
  components: {
    VNode,
    VNodeFocusRing,
    VEdgeGroups: _sfc_main$d,
    VEdgeBackgrounds: _sfc_main$b,
    VEdgeLabels,
    VBackgroundViewport: _sfc_main$9,
    VBackgroundGrid: _sfc_main$8,
    VPaths,
    VMarkerHead: _sfc_main$2
  },
  props: {
    nodes: {
      type: Object,
      default: () => ({})
    },
    edges: {
      type: Object,
      default: () => ({})
    },
    layouts: {
      type: Object,
      default: () => ({})
    },
    zoomLevel: {
      type: Number,
      default: 1
    },
    selectedNodes: {
      type: Array,
      default: () => []
    },
    selectedEdges: {
      type: Array,
      default: () => []
    },
    configs: {
      type: Object,
      default: () => ({})
    },
    paths: {
      type: Array,
      default: () => []
    },
    layers: {
      type: Object,
      default: () => ({})
    },
    eventHandlers: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:zoomLevel", "update:selectedNodes", "update:selectedEdges", "update:layouts"],
  setup(props, { emit, slots }) {
    const emitter = provideEventEmitter();
    Object.entries(props.eventHandlers).forEach(([type, event]) => {
      emitter.on(type, event);
    });
    const configs = provideConfigs(props.configs);
    const layerDefs = computed(() => {
      const definedSlots = new Set(Object.keys(slots));
      SYSTEM_SLOTS.forEach((s) => definedSlots.delete(s));
      const layers = Object.fromEntries(LayerPositions.map((n) => [n, []]));
      Object.assign(layers, Object.entries(props.layers).reduce((accum, [name, type]) => {
        definedSlots.delete(name);
        if (type in accum) {
          accum[type].push(name);
        } else {
          accum[type] = [name];
        }
        return accum;
      }, {}));
      layers["root"].push(...definedSlots);
      return layers;
    });
    const isShowGrid = computed(() => configs.view.grid.visible);
    const isShowBackgroundViewport = computed(() => {
      const layers = layerDefs.value;
      return isShowGrid.value || layers["background"].length > 0 || layers["grid"].length > 0;
    });
    const overrideNodes = computed(() => "override-node" in slots);
    const overrideNodeLabels = computed(() => "override-node-label" in slots);
    const overrideEdgeLabels = computed(() => "edge-label" in slots);
    const container = ref();
    const svg = ref();
    const show = ref(false);
    const zoomLevel = bindProp(props, "zoomLevel", emit, (v) => {
      v = Math.max(v, configs.view.minZoomLevel);
      v = Math.min(v, configs.view.maxZoomLevel);
      return v;
    });
    const { svgPanZoom: svgPanZoom2, onSvgPanZoomMounted, onSvgPanZoomUnmounted } = useSvgPanZoom(svg, {
      viewportSelector: ".v-viewport",
      minZoom: configs.view.minZoomLevel,
      maxZoom: configs.view.maxZoomLevel,
      fit: true,
      center: true,
      zoomEnabled: configs.view.zoomEnabled,
      onZoom: (_) => {
        var _a, _b;
        const z = (_b = (_a = svgPanZoom2.value) == null ? void 0 : _a.getRealZoom()) != null ? _b : 1;
        if (Math.abs(zoomLevel.value - z) >= 1e-6) {
          zoomLevel.value = z;
          emitter.emit("view:zoom", z);
        }
      },
      panEnabled: configs.view.panEnabled,
      onPan: (p) => emitter.emit("view:pan", p)
    });
    provideContainers({ container, svg, svgPanZoom: svgPanZoom2 });
    const rectSize = { width: 0, height: 0 };
    const resizeObserver = new ResizeObserver(() => {
      var _a, _b, _c;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.resize();
      const r = (_b = container.value) == null ? void 0 : _b.getBoundingClientRect();
      if (r) {
        const x = -(rectSize.width - r.width) / 2;
        const y = -(rectSize.height - r.height) / 2;
        (_c = svgPanZoom2.value) == null ? void 0 : _c.panBy({ x, y });
        const { width, height } = r;
        Object.assign(rectSize, { width, height });
        emitter.emit("view:resize", { x: r.x, y: r.y, width, height });
      }
    });
    onSvgPanZoomMounted(() => {
      var _a, _b;
      const c = nonNull(container.value, "svg-pan-zoom container");
      resizeObserver.observe(c);
      (_b = (_a = configs.view).onSvgPanZoomInitialized) == null ? void 0 : _b.call(_a, nonNull(svgPanZoom2.value, "svg-pan-zoom instance"));
      const r = c.getBoundingClientRect();
      const { width, height } = r;
      Object.assign(rectSize, { width, height });
    });
    onSvgPanZoomUnmounted(() => {
      resizeObserver.disconnect();
    });
    const applyAbsoluteZoomLevel = (absoluteZoomLevel) => {
      var _a;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.applyAbsoluteZoomLevel(absoluteZoomLevel, configs.view.minZoomLevel, configs.view.maxZoomLevel);
    };
    watch(() => configs.view.panEnabled, (v) => {
      var _a;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.setPanEnabled(v);
    });
    watch(() => configs.view.zoomEnabled, (v) => {
      var _a;
      (_a = svgPanZoom2.value) == null ? void 0 : _a.setZoomEnabled(v);
    });
    watch(zoomLevel, (v) => applyAbsoluteZoomLevel(v));
    watch(() => [configs.view.minZoomLevel, configs.view.maxZoomLevel], (_) => {
      applyAbsoluteZoomLevel(zoomLevel.value);
    });
    const { scale } = provideZoomLevel(zoomLevel, configs.view);
    onSvgPanZoomMounted(() => {
      const initialZoomLevel = props.zoomLevel;
      applyAbsoluteZoomLevel(initialZoomLevel);
    });
    const updateBorderBox = (callback) => {
      var _a;
      if (Object.keys(props.nodes).length > 0) {
        (_a = svgPanZoom2.value) == null ? void 0 : _a.updateBBox();
        nextTick(callback);
      } else {
        callback();
      }
    };
    const fitToContents = () => {
      updateBorderBox(() => {
        var _a;
        (_a = svgPanZoom2.value) == null ? void 0 : _a.fitToContents();
        emitter.emit("view:fit", void 0);
      });
    };
    const panToCenter = () => {
      updateBorderBox(() => {
        var _a;
        (_a = svgPanZoom2.value) == null ? void 0 : _a.center();
      });
    };
    const currentSelectedNodes = bindPropKeySet(props, "selectedNodes", props.nodes, emit);
    watch(currentSelectedNodes, (nodes) => emitter.emit("node:select", Array.from(nodes)));
    const currentSelectedEdges = bindPropKeySet(props, "selectedEdges", props.edges, emit);
    watch(currentSelectedEdges, (edges) => emitter.emit("edge:select", Array.from(edges)));
    const hoveredNodes = Reactive(new Set());
    const hoveredEdges = Reactive(new Set());
    const currentLayouts = Reactive({ nodes: {} });
    watch(() => props.layouts, () => Object.assign(currentLayouts, props.layouts), { deep: true, immediate: true });
    watch(currentLayouts, () => emit("update:layouts", currentLayouts), { deep: true });
    const visibleNodeFocusRing = computed(() => {
      return configs.node.focusring.visible;
    });
    const markers2 = provideMarkers();
    const dragging = ref(false);
    emitter.on("node:dragstart", (_) => dragging.value = true);
    emitter.on("node:dragend", (_) => dragging.value = false);
    emitter.on("view:mode", (mode) => {
      var _a, _b, _c, _d;
      if (configs.view.panEnabled) {
        if (mode === "default") {
          (_a = svgPanZoom2.value) == null ? void 0 : _a.enablePan();
        } else {
          (_b = svgPanZoom2.value) == null ? void 0 : _b.disablePan();
        }
      }
      if (configs.view.zoomEnabled) {
        if (mode === "default") {
          (_c = svgPanZoom2.value) == null ? void 0 : _c.enableZoom();
        } else {
          (_d = svgPanZoom2.value) == null ? void 0 : _d.disableZoom();
        }
      }
    });
    const { nodeStates, edgeStates } = provideStates(readonly(props.nodes), readonly(props.edges), currentSelectedNodes, currentSelectedEdges, hoveredNodes, hoveredEdges, readonly(configs), currentLayouts, scale);
    provideMouseOperation(svg, readonly(currentLayouts.nodes), readonly(zoomLevel), nodeStates, edgeStates, currentSelectedNodes, currentSelectedEdges, hoveredNodes, hoveredEdges, emitter);
    const visiblePaths = computed(() => configs.path.visible);
    const activateParams = () => ({
      layouts: Reactive(currentLayouts.nodes),
      nodes: readonly(props.nodes),
      edges: readonly(props.edges),
      configs: readonly(configs),
      scale: readonly(scale),
      emitter,
      svgPanZoom: nonNull(svgPanZoom2.value)
    });
    watch(() => configs.view.layoutHandler, (newHandler, oldHandler) => {
      oldHandler.deactivate();
      newHandler.activate(activateParams());
    });
    onSvgPanZoomMounted(() => {
      updateBorderBox(() => {
        const svg2 = nonNull(svgPanZoom2.value, "svg-pan-zoom");
        svg2.center();
        configs.view.layoutHandler.activate(activateParams());
        nextTick(() => {
          if (Object.keys(props.nodes).length > 0) {
            if (configs.view.fit) {
              fitToContents();
            } else {
              panToCenter();
            }
          } else {
            const sizes = svg2.getSizes();
            svg2.pan({
              x: sizes.width / 2,
              y: sizes.height / 2
            });
          }
          emitter.emit("view:load");
          show.value = true;
        });
      });
    });
    onSvgPanZoomUnmounted(() => {
      emitter.emit("view:unload");
      configs.view.layoutHandler.deactivate();
    });
    return {
      container,
      svg,
      show,
      svgPanZoom: svgPanZoom2,
      allConfigs: configs,
      layerDefs,
      isShowGrid,
      isShowBackgroundViewport,
      overrideNodes,
      overrideNodeLabels,
      overrideEdgeLabels,
      scale,
      nodeStates,
      currentSelectedNodes,
      markers: markers2,
      dragging,
      currentLayouts,
      visibleNodeFocusRing,
      visiblePaths,
      fitToContents,
      panToCenter
    };
  },
  methods: {
    zoomIn() {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.zoomIn();
    },
    zoomOut() {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.zoomOut();
    },
    panTo(point) {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.pan(point);
    },
    panBy(point) {
      var _a;
      (_a = this.svgPanZoom) == null ? void 0 : _a.panBy(point);
    },
    getPan() {
      return nonNull(this.svgPanZoom).getPan();
    },
    getSizes() {
      const sizes = nonNull(this.svgPanZoom).getSizes();
      return {
        width: sizes.width,
        height: sizes.height,
        viewBox: sizes.viewBox
      };
    },
    getAsSvg() {
      const element = this.svg;
      const viewport = element == null ? void 0 : element.querySelector(".v-viewport");
      const target = element == null ? void 0 : element.cloneNode(true);
      if (viewport) {
        const box = viewport.getBBox();
        const z = 1 / this.scale;
        const svg = {
          x: Math.floor((box.x - 10) * z),
          y: Math.floor((box.y - 10) * z),
          width: Math.ceil((box.width + 20) * z),
          height: Math.ceil((box.height + 20) * z)
        };
        target.setAttribute("width", svg.width.toString());
        target.setAttribute("height", svg.height.toString());
        const v = target.querySelector(".v-viewport");
        v.setAttribute("transform", `translate(${-svg.x} ${-svg.y}), scale(${z})`);
        v.removeAttribute("style");
        target.setAttribute("viewBox", `0 0 ${svg.width} ${svg.height}`);
      }
      let data = target.outerHTML;
      data = data.replaceAll(/ data-v-[0-9a-z]+=""/g, "");
      data = data.replaceAll(/<!--[\s\S]*?-->/mg, "");
      return data;
    }
  }
});
const _hoisted_1 = {
  ref: "container",
  class: "v-network-graph"
};
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { class: "v-viewport" };
const _hoisted_4 = { class: "v-layer-edges" };
const _hoisted_5 = {
  key: 1,
  class: "v-layer-nodes-selections"
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_v_marker_head = resolveComponent("v-marker-head");
  const _component_v_background_grid = resolveComponent("v-background-grid");
  const _component_v_background_viewport = resolveComponent("v-background-viewport");
  const _component_v_edge_backgrounds = resolveComponent("v-edge-backgrounds");
  const _component_v_edge_groups = resolveComponent("v-edge-groups");
  const _component_v_edge_labels = resolveComponent("v-edge-labels");
  const _component_v_node_focus_ring = resolveComponent("v-node-focus-ring");
  const _component_v_node = resolveComponent("v-node");
  const _component_v_paths = resolveComponent("v-paths");
  return openBlock(), createElementBlock("div", _hoisted_1, [
    (openBlock(), createElementBlock("svg", {
      ref: "svg",
      class: normalizeClass(["v-canvas", { show: _ctx.show, dragging: _ctx.dragging }]),
      width: "500",
      height: "500",
      viewBox: "0 0 500 500"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["root"], (layerName) => {
        return renderSlot(_ctx.$slots, layerName, {
          key: layerName,
          scale: _ctx.scale
        }, void 0, true);
      }), 128)),
      Object.keys(_ctx.markers).length > 0 ? (openBlock(), createElementBlock("defs", _hoisted_2, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.markers, (marker, id) => {
          return openBlock(), createBlock(_component_v_marker_head, {
            id,
            key: id,
            marker,
            scale: _ctx.scale
          }, null, 8, ["id", "marker", "scale"]);
        }), 128))
      ])) : createCommentVNode("", true),
      _ctx.isShowBackgroundViewport ? (openBlock(), createBlock(_component_v_background_viewport, { key: 1 }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["background"], (layerName) => {
            return openBlock(), createElementBlock("g", {
              key: layerName,
              class: "v-layer"
            }, [
              renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
            ]);
          }), 128)),
          _ctx.isShowGrid ? (openBlock(), createBlock(_component_v_background_grid, { key: 0 })) : createCommentVNode("", true),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["grid"], (layerName) => {
            return openBlock(), createElementBlock("g", {
              key: layerName,
              class: "v-layer"
            }, [
              renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
            ]);
          }), 128))
        ]),
        _: 3
      })) : createCommentVNode("", true),
      createElementVNode("g", _hoisted_3, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["base"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        createElementVNode("g", _hoisted_4, [
          createVNode(_component_v_edge_backgrounds),
          createVNode(_component_v_edge_groups)
        ]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["edges"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        _ctx.overrideEdgeLabels ? (openBlock(), createBlock(_component_v_edge_labels, { key: 0 }, {
          "edge-label": withCtx((slotProps) => [
            renderSlot(_ctx.$slots, "edge-label", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
          ]),
          _: 3
        })) : createCommentVNode("", true),
        _ctx.visibleNodeFocusRing ? (openBlock(), createElementBlock("g", _hoisted_5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentSelectedNodes, (nodeId) => {
            return openBlock(), createBlock(_component_v_node_focus_ring, {
              id: nodeId,
              key: nodeId,
              state: _ctx.nodeStates[nodeId],
              pos: _ctx.currentLayouts.nodes[nodeId]
            }, null, 8, ["id", "state", "pos"]);
          }), 128))
        ])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["focusring"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        createVNode(TransitionGroup, {
          name: _ctx.allConfigs.node.transition,
          css: !!_ctx.allConfigs.node.transition,
          tag: "g",
          class: "v-layer-nodes"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.nodeStates, (state, nodeId) => {
              return openBlock(), createBlock(_component_v_node, {
                id: nodeId.toString(),
                key: nodeId,
                state,
                pos: _ctx.currentLayouts.nodes[nodeId]
              }, createSlots({ _: 2 }, [
                _ctx.overrideNodes ? {
                  name: "override-node",
                  fn: withCtx((slotProps) => [
                    renderSlot(_ctx.$slots, "override-node", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
                  ])
                } : void 0,
                _ctx.overrideNodeLabels ? {
                  name: "override-node-label",
                  fn: withCtx((slotProps) => [
                    renderSlot(_ctx.$slots, "override-node-label", normalizeProps(guardReactiveProps(slotProps)), void 0, true)
                  ])
                } : void 0
              ]), 1032, ["id", "state", "pos"]);
            }), 128))
          ]),
          _: 3
        }, 8, ["name", "css"]),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["nodes"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128)),
        _ctx.visiblePaths ? (openBlock(), createBlock(_component_v_paths, {
          key: 2,
          paths: _ctx.paths,
          edges: _ctx.edges
        }, null, 8, ["paths", "edges"])) : createCommentVNode("", true),
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.layerDefs["paths"], (layerName) => {
          return openBlock(), createElementBlock("g", {
            key: layerName,
            class: "v-layer"
          }, [
            renderSlot(_ctx.$slots, layerName, { scale: _ctx.scale }, void 0, true)
          ]);
        }), 128))
      ])
    ], 2))
  ], 512);
}
var networkGraph = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render], ["__scopeId", "data-v-f92e6cce"]]);
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    area: {
      type: Object,
      required: true
    },
    config: {
      type: Object,
      required: true
    },
    text: {
      type: String,
      required: false,
      default: ""
    },
    align: {
      type: String,
      required: false,
      default: "center"
    },
    verticalAlign: {
      type: String,
      required: false,
      default: "center"
    },
    edge: {
      type: Object,
      required: false,
      default: void 0
    },
    hovered: {
      type: Boolean,
      required: false,
      default: false
    },
    selected: {
      type: Boolean,
      required: false,
      default: false
    },
    scale: {
      type: Number,
      required: false,
      default: void 0
    }
  },
  setup(__props, { expose }) {
    const props = __props;
    const x = ref(0);
    const y = ref(0);
    const textAnchor = ref("middle");
    const dominantBaseline = ref("central");
    const angle = ref(0);
    watchEffect(() => {
      const s = props.area.source;
      const t = props.area.target;
      if (props.align === "source") {
        if (s.above.x == t.above.x) {
          textAnchor.value = s.above.y > t.above.y ? "start" : "end";
        } else {
          textAnchor.value = s.above.x < t.above.x ? "start" : "end";
        }
        if (props.verticalAlign === "above") {
          x.value = s.above.x;
          y.value = s.above.y;
          dominantBaseline.value = "text-top";
        } else if (props.verticalAlign === "below") {
          x.value = s.below.x;
          y.value = s.below.y;
          dominantBaseline.value = "hanging";
        } else {
          x.value = (s.above.x + s.below.x) / 2;
          y.value = (s.above.y + s.below.y) / 2;
          dominantBaseline.value = "central";
        }
      } else if (props.align === "target") {
        if (s.above.x == t.above.x) {
          textAnchor.value = s.above.y < t.above.y ? "start" : "end";
        } else {
          textAnchor.value = s.above.x > t.above.x ? "start" : "end";
        }
        if (props.verticalAlign === "above") {
          x.value = t.above.x;
          y.value = t.above.y;
          dominantBaseline.value = "text-top";
        } else if (props.verticalAlign === "below") {
          x.value = t.below.x;
          y.value = t.below.y;
          dominantBaseline.value = "hanging";
        } else {
          x.value = (t.above.x + t.below.x) / 2;
          y.value = (t.above.y + t.below.y) / 2;
          dominantBaseline.value = "central";
        }
      } else {
        textAnchor.value = "middle";
        if (props.verticalAlign === "above") {
          x.value = (s.above.x + t.above.x) / 2;
          y.value = (s.above.y + t.above.y) / 2;
          dominantBaseline.value = "text-top";
        } else if (props.verticalAlign === "below") {
          x.value = (s.below.x + t.below.x) / 2;
          y.value = (s.below.y + t.below.y) / 2;
          dominantBaseline.value = "hanging";
        } else {
          x.value = (s.above.x + t.below.x) / 2;
          y.value = (s.above.y + t.below.y) / 2;
          dominantBaseline.value = "central";
        }
      }
      let degree = fromPositions(s.above, t.above).v.angleDeg();
      if (degree < -90 || degree >= 90) {
        degree = degree + 180;
        if (degree > 180) {
          degree -= 360;
        }
      }
      angle.value = degree;
    });
    const updatedConfig = computed(() => {
      if (dominantBaseline.value === "central" && !props.config.background) {
        return __spreadProps(__spreadValues({}, props.config), {
          background: {
            visible: true,
            color: "#ffffff",
            padding: {
              vertical: 1,
              horizontal: 4
            },
            borderRadius: 2
          }
        });
      } else {
        return props.config;
      }
    });
    expose({ x, y, textAnchor, dominantBaseline, angle, updatedConfig });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(_sfc_main$k, {
        class: "v-edge-label",
        text: __props.text,
        x: x.value,
        y: y.value,
        config: unref(updatedConfig),
        "text-anchor": textAnchor.value,
        "dominant-baseline": dominantBaseline.value,
        transform: `rotate(${angle.value} ${x.value} ${y.value})`
      }, null, 8, ["text", "x", "y", "config", "text-anchor", "dominant-baseline", "transform"]);
    };
  }
});
var components = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  VNetworkGraph: networkGraph,
  VEdgeLabel: _sfc_main,
  VLabelText: _sfc_main$k
});
const DEFAULT_GRID = 10;
class GridLayout extends SimpleLayout {
  constructor(options = {}) {
    super();
    this.options = options;
  }
  setNodePosition(nodeLayout, pos) {
    const grid = this.options.grid || DEFAULT_GRID;
    nodeLayout.value.x = Math.floor(pos.x / grid) * grid;
    nodeLayout.value.y = Math.floor(pos.y / grid) * grid;
  }
}
const install = function(app) {
  Object.entries(components).forEach(([componentName, component]) => {
    app.component(componentName, component);
  });
};
export { Config, GridLayout, LayerPositions, NodeLabelDirection, SimpleLayout, _sfc_main as VEdgeLabel, _sfc_main$k as VLabelText, networkGraph as VNetworkGraph, configsWithType, install as default, getFullConfigs, useStates, withSelf };
//# sourceMappingURL=index.es.js.map
